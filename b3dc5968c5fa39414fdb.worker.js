/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		        if (installedModules[moduleId]) return installedModules[moduleId].exports;

/******/ 		        var module = installedModules[moduleId] = {
/******/ 		          i: moduleId,
/******/ 		          l: false,
/******/ 		          exports: {}
/******/ 		        };

/******/ 		        if (!modules[moduleId] && typeof moduleId === 'string') {
/******/ 		          var newModuleId;
/******/ 		          if (modules[newModuleId = moduleId + '.js'] || modules[newModuleId = moduleId + '.ts']) {
/******/ 		            moduleId = newModuleId;

/******/ 		            installedModules[moduleId] = module;
/******/ 		          }
/******/ 		        }

/******/ 		        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		        module.l = true;

/******/ 		        return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _levelGenerator = __webpack_require__(\"levelGenerator.js\");\n\nself.onmessage = function (e) {\n\tif (e.data.step = \"generate\") {\n\t\tvar lg = new _levelGenerator.LevelGenerator(e.data.options);\n\t\tlg.Generate(function (grid) {\n\t\t\tself.postMessage(grid);\n\t\t});\n\t}\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGV2ZWxXb3JrZXIuanM/YTQ3YSJdLCJuYW1lcyI6WyJzZWxmIiwib25tZXNzYWdlIiwiZSIsImRhdGEiLCJzdGVwIiwibGciLCJvcHRpb25zIiwiR2VuZXJhdGUiLCJncmlkIiwicG9zdE1lc3NhZ2UiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUFBLEtBQUtDLFNBQUwsR0FBaUIsVUFBVUMsQ0FBVixFQUFhO0FBQzdCLEtBQUlBLEVBQUVDLElBQUYsQ0FBT0MsSUFBUCxHQUFjLFVBQWxCLEVBQThCO0FBQzdCLE1BQUlDLEtBQUssbUNBQW1CSCxFQUFFQyxJQUFGLENBQU9HLE9BQTFCLENBQVQ7QUFDQUQsS0FBR0UsUUFBSCxDQUFZLFVBQUNDLElBQUQsRUFBVTtBQUNyQlIsUUFBS1MsV0FBTCxDQUFpQkQsSUFBakI7QUFDQSxHQUZEO0FBR0E7QUFFRCxDQVJEIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xldmVsR2VuZXJhdG9yfSBmcm9tICdsZXZlbEdlbmVyYXRvcidcblxuc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuXHRpZiAoZS5kYXRhLnN0ZXAgPSBcImdlbmVyYXRlXCIpIHtcblx0XHRsZXQgbGcgPSBuZXcgTGV2ZWxHZW5lcmF0b3IoZS5kYXRhLm9wdGlvbnMpO1xuXHRcdGxnLkdlbmVyYXRlKChncmlkKSA9PiB7XG5cdFx0XHRzZWxmLnBvc3RNZXNzYWdlKGdyaWQpO1xuXHRcdH0pO1xuXHR9XG5cdFxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sZXZlbFdvcmtlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 1:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010\n// http://baagoe.com/en/RandomMusings/javascript/\n// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n// Original work is under MIT license -\n\n// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n(function(global, module, define) {\n\nfunction Alea(seed) {\n  var me = this, mash = Mash();\n\n  me.next = function() {\n    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32\n    me.s0 = me.s1;\n    me.s1 = me.s2;\n    return me.s2 = t - (me.c = t | 0);\n  };\n\n  // Apply the seeding algorithm from Baagoe.\n  me.c = 1;\n  me.s0 = mash(' ');\n  me.s1 = mash(' ');\n  me.s2 = mash(' ');\n  me.s0 -= mash(seed);\n  if (me.s0 < 0) { me.s0 += 1; }\n  me.s1 -= mash(seed);\n  if (me.s1 < 0) { me.s1 += 1; }\n  me.s2 -= mash(seed);\n  if (me.s2 < 0) { me.s2 += 1; }\n  mash = null;\n}\n\nfunction copy(f, t) {\n  t.c = f.c;\n  t.s0 = f.s0;\n  t.s1 = f.s1;\n  t.s2 = f.s2;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  var xg = new Alea(seed),\n      state = opts && opts.state,\n      prng = xg.next;\n  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }\n  prng.double = function() {\n    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n  };\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nfunction Mash() {\n  var n = 0xefc8249d;\n\n  var mash = function(data) {\n    data = data.toString();\n    for (var i = 0; i < data.length; i++) {\n      n += data.charCodeAt(i);\n      var h = 0.02519603282416938 * n;\n      n = h >>> 0;\n      h -= n;\n      h *= n;\n      n = h >>> 0;\n      h -= n;\n      n += h * 0x100000000; // 2^32\n    }\n    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n  };\n\n  return mash;\n}\n\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(3) && __webpack_require__(4)) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.alea = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(3)   // present with an AMD loader\n);\n\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NlZWRyYW5kb20vbGliL2FsZWEuanM/ZDUzMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoia0NBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNDQUFzQztBQUNqRTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUIsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdEQUFxQixhQUFhLEVBQUU7QUFDcEMsQ0FBQztBQUNEO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBIHBvcnQgb2YgYW4gYWxnb3JpdGhtIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2UuY29tPiwgMjAxMFxuLy8gaHR0cDovL2JhYWdvZS5jb20vZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0L1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25xdWlubGFuL2JldHRlci1yYW5kb20tbnVtYmVycy1mb3ItamF2YXNjcmlwdC1taXJyb3Jcbi8vIE9yaWdpbmFsIHdvcmsgaXMgdW5kZXIgTUlUIGxpY2Vuc2UgLVxuXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5vcmc+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5cblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gQWxlYShzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIG1hc2ggPSBNYXNoKCk7XG5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gMjA5MTYzOSAqIG1lLnMwICsgbWUuYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgbWUuczAgPSBtZS5zMTtcbiAgICBtZS5zMSA9IG1lLnMyO1xuICAgIHJldHVybiBtZS5zMiA9IHQgLSAobWUuYyA9IHQgfCAwKTtcbiAgfTtcblxuICAvLyBBcHBseSB0aGUgc2VlZGluZyBhbGdvcml0aG0gZnJvbSBCYWFnb2UuXG4gIG1lLmMgPSAxO1xuICBtZS5zMCA9IG1hc2goJyAnKTtcbiAgbWUuczEgPSBtYXNoKCcgJyk7XG4gIG1lLnMyID0gbWFzaCgnICcpO1xuICBtZS5zMCAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczAgPCAwKSB7IG1lLnMwICs9IDE7IH1cbiAgbWUuczEgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMxIDwgMCkgeyBtZS5zMSArPSAxOyB9XG4gIG1lLnMyIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMiA8IDApIHsgbWUuczIgKz0gMTsgfVxuICBtYXNoID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYyA9IGYuYztcbiAgdC5zMCA9IGYuczA7XG4gIHQuczEgPSBmLnMxO1xuICB0LnMyID0gZi5zMjtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgQWxlYShzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IHhnLm5leHQ7XG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgKiAweDEwMDAwMDAwMCkgfCAwOyB9XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHBybmcoKSArIChwcm5nKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjsgLy8gMl4tNTNcbiAgfTtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmZ1bmN0aW9uIE1hc2goKSB7XG4gIHZhciBuID0gMHhlZmM4MjQ5ZDtcblxuICB2YXIgbWFzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBoICo9IG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgfVxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9O1xuXG4gIHJldHVybiBtYXNoO1xufVxuXG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMuYWxlYSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NlZWRyYW5kb20vbGliL2FsZWEuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 2:
/***/ (function(module, exports) {

	eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 3:
/***/ (function(module, exports) {

	eval("module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcz8wYmJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZCQUE2QixtREFBbUQiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcImRlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdFwiKTsgfTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 4:
/***/ (function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanM/NWY3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 5:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {// A Javascript implementaion of the \"xor128\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this, strseed = '';\n\n  me.x = 0;\n  me.y = 0;\n  me.z = 0;\n  me.w = 0;\n\n  // Set up generator function.\n  me.next = function() {\n    var t = me.x ^ (me.x << 11);\n    me.x = me.y;\n    me.y = me.z;\n    me.z = me.w;\n    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);\n  };\n\n  if (seed === (seed | 0)) {\n    // Integer seed.\n    me.x = seed;\n  } else {\n    // String seed.\n    strseed += seed;\n  }\n\n  // Mix in string seed, then discard an initial batch of 64 values.\n  for (var k = 0; k < strseed.length + 64; k++) {\n    me.x ^= strseed.charCodeAt(k) | 0;\n    me.next();\n  }\n}\n\nfunction copy(f, t) {\n  t.x = f.x;\n  t.y = f.y;\n  t.z = f.z;\n  t.w = f.w;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(3) && __webpack_require__(4)) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.xor128 = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(3)   // present with an AMD loader\n);\n\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NlZWRyYW5kb20vbGliL3hvcjEyOC5qcz82ODNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJrQ0FBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQixFQUFFO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdEQUFxQixhQUFhLEVBQUU7QUFDcEMsQ0FBQztBQUNEO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3IxMjhcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gR2VvcmdlIE1hcnNhZ2xpYS4gIFNlZSBodHRwOi8vd3d3LmpzdGF0c29mdC5vcmcvdjA4L2kxNC9wYXBlclxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gbWUueCBeIChtZS54IDw8IDExKTtcbiAgICBtZS54ID0gbWUueTtcbiAgICBtZS55ID0gbWUuejtcbiAgICBtZS56ID0gbWUudztcbiAgICByZXR1cm4gbWUudyBePSAobWUudyA+Pj4gMTkpIF4gdCBeICh0ID4+PiA4KTtcbiAgfTtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcjEyOCA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NlZWRyYW5kb20vbGliL3hvcjEyOC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "seedrandom":
/***/ (function(module, exports, __webpack_require__) {

	eval("// A library of seedable RNGs implemented in Javascript.\n//\n// Usage:\n//\n// var seedrandom = require('seedrandom');\n// var random = seedrandom(1); // or any seed.\n// var x = random();       // 0 <= x < 1.  Every bit is random.\n// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.\n\n// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.\n// Period: ~2^116\n// Reported to pass all BigCrush tests.\nvar alea = __webpack_require__(1);\n\n// xor128, a pure xor-shift generator by George Marsaglia.\n// Period: 2^128-1.\n// Reported to fail: MatrixRank and LinearComp.\nvar xor128 = __webpack_require__(5);\n\n// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.\n// Period: 2^192-2^32\n// Reported to fail: CollisionOver, SimpPoker, and LinearComp.\nvar xorwow = __webpack_require__(6);\n\n// xorshift7, by François Panneton and Pierre L'ecuyer, takes\n// a different approach: it adds robustness by allowing more shifts\n// than Marsaglia's original three.  It is a 7-shift generator\n// with 256 bits, that passes BigCrush with no systmatic failures.\n// Period 2^256-1.\n// No systematic BigCrush failures reported.\nvar xorshift7 = __webpack_require__(7);\n\n// xor4096, by Richard Brent, is a 4096-bit xor-shift with a\n// very long period that also adds a Weyl generator. It also passes\n// BigCrush with no systematic failures.  Its long period may\n// be useful if you have many generators and need to avoid\n// collisions.\n// Period: 2^4128-2^32.\n// No systematic BigCrush failures reported.\nvar xor4096 = __webpack_require__(8);\n\n// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random\n// number generator derived from ChaCha, a modern stream cipher.\n// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n// Period: ~2^127\n// No systematic BigCrush failures reported.\nvar tychei = __webpack_require__(9);\n\n// The original ARC4-based prng included in this library.\n// Period: ~2^1600\nvar sr = __webpack_require__(10);\n\nsr.alea = alea;\nsr.xor128 = xor128;\nsr.xorwow = xorwow;\nsr.xorshift7 = xorshift7;\nsr.xor4096 = xor4096;\nsr.tychei = tychei;\n\nmodule.exports = sr;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NlZWRyYW5kb20vaW5kZXguanM/MGYxMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLG9CQUFvQjtBQUNwQiwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoic2VlZHJhbmRvbS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEEgbGlicmFyeSBvZiBzZWVkYWJsZSBSTkdzIGltcGxlbWVudGVkIGluIEphdmFzY3JpcHQuXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKCdzZWVkcmFuZG9tJyk7XG4vLyB2YXIgcmFuZG9tID0gc2VlZHJhbmRvbSgxKTsgLy8gb3IgYW55IHNlZWQuXG4vLyB2YXIgeCA9IHJhbmRvbSgpOyAgICAgICAvLyAwIDw9IHggPCAxLiAgRXZlcnkgYml0IGlzIHJhbmRvbS5cbi8vIHZhciB4ID0gcmFuZG9tLnF1aWNrKCk7IC8vIDAgPD0geCA8IDEuICAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXG5cbi8vIGFsZWEsIGEgNTMtYml0IG11bHRpcGx5LXdpdGgtY2FycnkgZ2VuZXJhdG9yIGJ5IEpvaGFubmVzIEJhYWfDuGUuXG4vLyBQZXJpb2Q6IH4yXjExNlxuLy8gUmVwb3J0ZWQgdG8gcGFzcyBhbGwgQmlnQ3J1c2ggdGVzdHMuXG52YXIgYWxlYSA9IHJlcXVpcmUoJy4vbGliL2FsZWEnKTtcblxuLy8geG9yMTI4LCBhIHB1cmUgeG9yLXNoaWZ0IGdlbmVyYXRvciBieSBHZW9yZ2UgTWFyc2FnbGlhLlxuLy8gUGVyaW9kOiAyXjEyOC0xLlxuLy8gUmVwb3J0ZWQgdG8gZmFpbDogTWF0cml4UmFuayBhbmQgTGluZWFyQ29tcC5cbnZhciB4b3IxMjggPSByZXF1aXJlKCcuL2xpYi94b3IxMjgnKTtcblxuLy8geG9yd293LCBHZW9yZ2UgTWFyc2FnbGlhJ3MgMTYwLWJpdCB4b3Itc2hpZnQgY29tYmluZWQgcGx1cyB3ZXlsLlxuLy8gUGVyaW9kOiAyXjE5Mi0yXjMyXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBDb2xsaXNpb25PdmVyLCBTaW1wUG9rZXIsIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcndvdyA9IHJlcXVpcmUoJy4vbGliL3hvcndvdycpO1xuXG4vLyB4b3JzaGlmdDcsIGJ5IEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyLCB0YWtlc1xuLy8gYSBkaWZmZXJlbnQgYXBwcm9hY2g6IGl0IGFkZHMgcm9idXN0bmVzcyBieSBhbGxvd2luZyBtb3JlIHNoaWZ0c1xuLy8gdGhhbiBNYXJzYWdsaWEncyBvcmlnaW5hbCB0aHJlZS4gIEl0IGlzIGEgNy1zaGlmdCBnZW5lcmF0b3Jcbi8vIHdpdGggMjU2IGJpdHMsIHRoYXQgcGFzc2VzIEJpZ0NydXNoIHdpdGggbm8gc3lzdG1hdGljIGZhaWx1cmVzLlxuLy8gUGVyaW9kIDJeMjU2LTEuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcnNoaWZ0NyA9IHJlcXVpcmUoJy4vbGliL3hvcnNoaWZ0NycpO1xuXG4vLyB4b3I0MDk2LCBieSBSaWNoYXJkIEJyZW50LCBpcyBhIDQwOTYtYml0IHhvci1zaGlmdCB3aXRoIGFcbi8vIHZlcnkgbG9uZyBwZXJpb2QgdGhhdCBhbHNvIGFkZHMgYSBXZXlsIGdlbmVyYXRvci4gSXQgYWxzbyBwYXNzZXNcbi8vIEJpZ0NydXNoIHdpdGggbm8gc3lzdGVtYXRpYyBmYWlsdXJlcy4gIEl0cyBsb25nIHBlcmlvZCBtYXlcbi8vIGJlIHVzZWZ1bCBpZiB5b3UgaGF2ZSBtYW55IGdlbmVyYXRvcnMgYW5kIG5lZWQgdG8gYXZvaWRcbi8vIGNvbGxpc2lvbnMuXG4vLyBQZXJpb2Q6IDJeNDEyOC0yXjMyLlxuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB4b3I0MDk2ID0gcmVxdWlyZSgnLi9saWIveG9yNDA5NicpO1xuXG4vLyBUeWNoZS1pLCBieSBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8sIGlzIGEgYml0LXNoaWZ0aW5nIHJhbmRvbVxuLy8gbnVtYmVyIGdlbmVyYXRvciBkZXJpdmVkIGZyb20gQ2hhQ2hhLCBhIG1vZGVybiBzdHJlYW0gY2lwaGVyLlxuLy8gaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcbi8vIFBlcmlvZDogfjJeMTI3XG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHR5Y2hlaSA9IHJlcXVpcmUoJy4vbGliL3R5Y2hlaScpO1xuXG4vLyBUaGUgb3JpZ2luYWwgQVJDNC1iYXNlZCBwcm5nIGluY2x1ZGVkIGluIHRoaXMgbGlicmFyeS5cbi8vIFBlcmlvZDogfjJeMTYwMFxudmFyIHNyID0gcmVxdWlyZSgnLi9zZWVkcmFuZG9tJyk7XG5cbnNyLmFsZWEgPSBhbGVhO1xuc3IueG9yMTI4ID0geG9yMTI4O1xuc3IueG9yd293ID0geG9yd293O1xuc3IueG9yc2hpZnQ3ID0geG9yc2hpZnQ3O1xuc3IueG9yNDA5NiA9IHhvcjQwOTY7XG5zci50eWNoZWkgPSB0eWNoZWk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2VlZHJhbmRvbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gc2VlZHJhbmRvbVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "levelGenerator.js":
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.LevelGenerator = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _seedrandom = __webpack_require__(\"seedrandom\");\n\nvar _seedrandom2 = _interopRequireDefault(_seedrandom);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar random = function random(min, max) {\n\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nvar LevelGenerator = exports.LevelGenerator = function () {\n\tfunction LevelGenerator(options) {\n\t\t_classCallCheck(this, LevelGenerator);\n\n\t\tif (options.seed) {\n\t\t\t(0, _seedrandom2.default)(options.seed, { global: true });\n\t\t}\n\n\t\tthis.width = options.width || 25;\n\t\tthis.height = options.height || 25;\n\t\tthis.roomAttempts = options.roomAttempts || 50;\n\t\tthis.maxSize = options.maxSize || 8;\n\t\tthis.minSize = options.minSize || 5;\n\t\tthis.windyness = options.windyness || 100;\n\t\tthis.wallWidth = options.wallWidth || 1;\n\t\tthis.mazeWidth = options.mazeWidth || 2;\n\t\tthis.minDoors = options.minDoors || 1;\n\t\tthis.maxDoors = options.maxDoors || 4;\n\t\tthis.animate = options.animate || false;\n\t\tthis.animationDelay = options.animationDelay || 10;\n\t}\n\n\t_createClass(LevelGenerator, [{\n\t\tkey: \"Generate\",\n\t\tvalue: function Generate(updateFrame) {\n\t\t\tthis.updateFrame = updateFrame;\n\n\t\t\tthis.InitGrid();\n\n\t\t\tconsole.log(\"Adding rooms...\");\n\n\t\t\tthis.AddRooms();\n\n\t\t\tconsole.log(\"Creating maze...\");\n\n\t\t\tthis.CreateMaze(0, 0);\n\n\t\t\tconsole.log(\"Opening rooms...\");\n\n\t\t\tthis.OpenRooms();\n\n\t\t\tconsole.log(\"Removing dead ends...\");\n\n\t\t\tthis.RemoveDeadEnds();\n\n\t\t\tconsole.log(\"Removing slack...\");\n\n\t\t\tthis.ReduceSlack();\n\n\t\t\tconsole.log(\"Removing maze walls...\");\n\n\t\t\tthis.RemoveMazeWalls();\n\n\t\t\tconsole.log(\"Removing excess walls...\");\n\n\t\t\tthis.RemoveExcessWall();\n\n\t\t\tconsole.log(\"Removing artifacts...\");\n\n\t\t\tthis.RemoveArtifacts();\n\n\t\t\tthis.FinalFrame();\n\t\t}\n\t}, {\n\t\tkey: \"UpdateFrame\",\n\t\tvalue: function UpdateFrame() {\n\t\t\tif (this.updateFrame && this.animate) {\n\t\t\t\tthis.updateFrame(this.grid);\n\n\t\t\t\tvar start = new Date().getTime();\n\t\t\t\tvar end = start;\n\t\t\t\twhile (end < start + this.animationDelay) {\n\t\t\t\t\tend = new Date().getTime();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"FinalFrame\",\n\t\tvalue: function FinalFrame() {\n\t\t\tif (this.updateFrame) {\n\t\t\t\tthis.updateFrame(this.grid);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"InitGrid\",\n\t\tvalue: function InitGrid() {\n\t\t\tthis.grid = [];\n\t\t\tthis.virtualGrid = [];\n\n\t\t\tvar actualWidth = this.wallWidth + this.width * (this.wallWidth + this.mazeWidth);\n\t\t\tvar actualHeight = this.wallWidth + this.height * (this.wallWidth + this.mazeWidth);\n\n\t\t\tfor (var i = 0; i < this.width; i++) {\n\t\t\t\tthis.virtualGrid[i] = [];\n\t\t\t\tfor (var j = 0; j < this.height; j++) {\n\t\t\t\t\tthis.virtualGrid[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var _i = 0; _i < actualWidth; _i++) {\n\t\t\t\tthis.grid[_i] = [];\n\t\t\t\tfor (var _j = 0; _j < actualHeight; _j++) {\n\t\t\t\t\tthis.grid[_i][_j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"AddRooms\",\n\t\tvalue: function AddRooms() {\n\t\t\tthis.rooms = [];\n\n\t\t\tfor (var i = 0; i < this.roomAttempts; i++) {\n\t\t\t\tvar roomWidth = random(this.minSize, this.maxSize);\n\t\t\t\tvar roomHeight = random(this.minSize, this.maxSize);\n\n\t\t\t\tvar x = random(1, this.width - roomWidth - 1);\n\t\t\t\tvar y = random(1, this.height - roomHeight - 1);\n\n\t\t\t\tvar xBorder = x + roomWidth;\n\t\t\t\tvar yBorder = y + roomHeight;\n\n\t\t\t\tvar overlaps = false;\n\n\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\tvar _didIteratorError = false;\n\t\t\t\tvar _iteratorError = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator = this.rooms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\tvar room = _step.value;\n\n\t\t\t\t\t\tif (room.x <= xBorder && room.xBorder >= x && room.y <= yBorder && room.yBorder >= y) {\n\t\t\t\t\t\t\toverlaps = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t_iteratorError = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (overlaps) continue;\n\n\t\t\t\tvar newRoom = {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\txBorder: xBorder,\n\t\t\t\t\tyBorder: yBorder\n\t\t\t\t};\n\n\t\t\t\tthis.rooms.push(newRoom);\n\t\t\t\tthis.DrawRoom(newRoom);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"CreateMaze\",\n\t\tvalue: function CreateMaze(x, y) {\n\t\t\tvar cells = [];\n\t\t\tvar lastDir = void 0;\n\n\t\t\tvar startingCell = {\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t};\n\n\t\t\tthis.DrawCell(startingCell);\n\n\t\t\tcells.push(startingCell);\n\n\t\t\twhile (cells.length > 0) {\n\t\t\t\tvar cell = cells[cells.length - 1];\n\n\t\t\t\tvar directions = this.GetDirections(cell, 1);\n\n\t\t\t\tif (directions.length > 0) {\n\t\t\t\t\tvar dir = void 0;\n\n\t\t\t\t\tvar hasLast = !!lastDir && directions.some(function (dir) {\n\t\t\t\t\t\treturn dir.x === lastDir.x && dir.y === lastDir.y;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (hasLast && random(0, 100) > this.windyness) {\n\t\t\t\t\t\tdir = lastDir;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar index = random(0, directions.length - 1);\n\t\t\t\t\t\tdir = directions[index];\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.DrawCellTo(cell, dir);\n\n\t\t\t\t\tthis.UpdateFrame();\n\n\t\t\t\t\tcells.push({\n\t\t\t\t\t\tx: cell.x + dir.x,\n\t\t\t\t\t\ty: cell.y + dir.y\n\t\t\t\t\t});\n\n\t\t\t\t\tlastDir = dir;\n\t\t\t\t} else {\n\t\t\t\t\t// Remove last cell in the current branch\n\t\t\t\t\tlastDir = null;\n\t\t\t\t\tcells.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"OpenRooms\",\n\t\tvalue: function OpenRooms() {\n\t\t\tif (!this.rooms) return;\n\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = this.rooms[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar room = _step2.value;\n\n\t\t\t\t\tvar allDirections = [];\n\t\t\t\t\tallDirections.push({ x: 0, y: -1 });\n\t\t\t\t\tallDirections.push({ x: 0, y: 1 });\n\t\t\t\t\tallDirections.push({ x: -1, y: 0 });\n\t\t\t\t\tallDirections.push({ x: 1, y: 0 });\n\n\t\t\t\t\tvar maxDoorsActual = this.maxDoors < 4 ? this.maxDoors : 4;\n\t\t\t\t\tvar numDoors = random(this.minDoors, maxDoorsActual);\n\n\t\t\t\t\tvar directions = [];\n\t\t\t\t\tvar indexes = [];\n\n\t\t\t\t\twhile (directions.length < numDoors) {\n\t\t\t\t\t\tvar newRandom = random(0, 3);\n\n\t\t\t\t\t\tif (!indexes.includes(newRandom)) {\n\t\t\t\t\t\t\tindexes.push(newRandom);\n\t\t\t\t\t\t\tdirections.push(allDirections[newRandom]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar _iteratorNormalCompletion3 = true;\n\t\t\t\t\tvar _didIteratorError3 = false;\n\t\t\t\t\tvar _iteratorError3 = undefined;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (var _iterator3 = directions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\t\t\t\tvar dir = _step3.value;\n\n\t\t\t\t\t\t\tvar x = dir.x === 1 ? room.xBorder - 1 : dir.x === -1 ? room.x : random(room.x + 1, room.xBorder - 2);\n\n\t\t\t\t\t\t\tvar y = dir.y === 1 ? room.yBorder - 1 : dir.y === -1 ? room.y : random(room.y + 1, room.yBorder - 2);\n\n\t\t\t\t\t\t\tthis.DrawWallTo({\n\t\t\t\t\t\t\t\tx: x,\n\t\t\t\t\t\t\t\ty: y\n\t\t\t\t\t\t\t}, dir, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t\t\t_iteratorError3 = err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"ReduceSlack\",\n\t\tvalue: function ReduceSlack() {\n\t\t\tvar slackLeft = true;\n\n\t\t\twhile (slackLeft) {\n\t\t\t\tslackLeft = false;\n\n\t\t\t\tfor (var x = 0; x < this.virtualGrid.length; x++) {\n\t\t\t\t\tfor (var y = 0; y < this.virtualGrid[x].length; y++) {\n\t\t\t\t\t\tif (this.virtualGrid[x][y] === 0) {\n\t\t\t\t\t\t\tvar startCell = { x: x, y: y };\n\t\t\t\t\t\t\tvar endCell = undefined;\n\t\t\t\t\t\t\tvar openings = this.CellWalls(startCell, 0);\n\n\t\t\t\t\t\t\t// Is the cell a corner\n\t\t\t\t\t\t\tif (openings.length === 2 && Math.abs(openings[0].x) !== Math.abs(openings[1].x)) {\n\t\t\t\t\t\t\t\tvar inLoop = true;\n\t\t\t\t\t\t\t\tvar offset = 1;\n\n\t\t\t\t\t\t\t\tvar cells = [];\n\t\t\t\t\t\t\t\tvar crossings = [];\n\n\t\t\t\t\t\t\t\tvar loopDirIndex = 0;\n\t\t\t\t\t\t\t\tvar cornerDirIndex = 1;\n\n\t\t\t\t\t\t\t\tvar firstAttempt = true;\n\n\t\t\t\t\t\t\t\tvar isValid = false;\n\n\t\t\t\t\t\t\t\t// Loop through all cells in slack until a corner is reached\n\t\t\t\t\t\t\t\twhile (inLoop) {\n\t\t\t\t\t\t\t\t\tvar xDiff = openings[loopDirIndex].x * offset;\n\t\t\t\t\t\t\t\t\tvar yDiff = openings[loopDirIndex].y * offset;\n\t\t\t\t\t\t\t\t\tvar nextCell = {\n\t\t\t\t\t\t\t\t\t\tx: x + xDiff,\n\t\t\t\t\t\t\t\t\t\ty: y + yDiff\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tvar nextOpenings = this.CellWalls(nextCell, 0);\n\n\t\t\t\t\t\t\t\t\t// If the cell does not have 2 or 3 openings, then it is no longer a slack\n\t\t\t\t\t\t\t\t\tif (nextOpenings.length === 2) {\n\t\t\t\t\t\t\t\t\t\t// If the cell is not a corner, continue to next cell.\n\t\t\t\t\t\t\t\t\t\tif (Math.abs(nextOpenings[0].x) === Math.abs(nextOpenings[1].x)) {\n\t\t\t\t\t\t\t\t\t\t\toffset++;\n\t\t\t\t\t\t\t\t\t\t\tcells.push(nextCell);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// If the cell is a corner, check that its a corner facing the same direction as the start cell.\n\t\t\t\t\t\t\t\t\t\t\tif ((nextOpenings[1].x == openings[cornerDirIndex].x || nextOpenings[0].x == openings[cornerDirIndex].x) && (nextOpenings[1].y == openings[cornerDirIndex].y || nextOpenings[0].y == openings[cornerDirIndex].y)) {\n\t\t\t\t\t\t\t\t\t\t\t\tendCell = nextCell;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// If the cell is a corner, there is no more cells to loop over\n\t\t\t\t\t\t\t\t\t\t\tinLoop = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (nextOpenings.length === 3) {\n\t\t\t\t\t\t\t\t\t\tvar isValidCrossing = nextOpenings.every(function (o) {\n\t\t\t\t\t\t\t\t\t\t\treturn o.x === openings[cornerDirIndex].x && o.y === openings[cornerDirIndex].y || o.x === openings[loopDirIndex].x && o.y === openings[loopDirIndex].y || o.x === -openings[loopDirIndex].x && o.y === -openings[loopDirIndex].y;\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tif (isValidCrossing) {\n\t\t\t\t\t\t\t\t\t\t\toffset++;\n\t\t\t\t\t\t\t\t\t\t\tcrossings.push(nextCell);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tinLoop = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tinLoop = false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (!inLoop) {\n\t\t\t\t\t\t\t\t\t\tvar isObstructed = false;\n\n\t\t\t\t\t\t\t\t\t\tif (endCell) {\n\t\t\t\t\t\t\t\t\t\t\tif (cells.length > 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion4 = true;\n\t\t\t\t\t\t\t\t\t\t\t\tvar _didIteratorError4 = false;\n\t\t\t\t\t\t\t\t\t\t\t\tvar _iteratorError4 = undefined;\n\n\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var _iterator4 = cells[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar cell = _step4.value;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.virtualGrid[cell.x + openings[cornerDirIndex].x][cell.y + openings[cornerDirIndex].y] == 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tisObstructed = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t_didIteratorError4 = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t_iteratorError4 = err;\n\t\t\t\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t_iterator4.return();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (_didIteratorError4) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!isObstructed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tisValid = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tvar startInsideCell = {\n\t\t\t\t\t\t\t\t\t\t\t\t\tx: x + openings[cornerDirIndex].x,\n\t\t\t\t\t\t\t\t\t\t\t\t\ty: y + openings[cornerDirIndex].y\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar startInsideWalls = this.CellWalls(startInsideCell, 1);\n\n\t\t\t\t\t\t\t\t\t\t\t\tisObstructed = !startInsideWalls.some(function (w) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn w.x === openings[loopDirIndex].x && w.y === openings[loopDirIndex].y;\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!isObstructed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tisValid = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ((!endCell || isObstructed) && firstAttempt) {\n\t\t\t\t\t\t\t\t\t\t\tinLoop = true;\n\t\t\t\t\t\t\t\t\t\t\tfirstAttempt = false;\n\t\t\t\t\t\t\t\t\t\t\toffset = 1;\n\t\t\t\t\t\t\t\t\t\t\tcells = [];\n\t\t\t\t\t\t\t\t\t\t\tendCell = undefined;\n\t\t\t\t\t\t\t\t\t\t\tcrossings = [];\n\n\t\t\t\t\t\t\t\t\t\t\tloopDirIndex = 1;\n\t\t\t\t\t\t\t\t\t\t\tcornerDirIndex = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (!isValid) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tslackLeft = true;\n\t\t\t\t\t\t\t\tthis.DrawCellFrom(startCell, openings[cornerDirIndex], 1);\n\n\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\n\t\t\t\t\t\t\t\tthis.DrawCellFrom(endCell, openings[cornerDirIndex], 1);\n\n\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\n\t\t\t\t\t\t\t\tthis.DrawWallTo(startCell, openings[loopDirIndex], 1);\n\n\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\n\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion5 = true;\n\t\t\t\t\t\t\t\tvar _didIteratorError5 = false;\n\t\t\t\t\t\t\t\tvar _iteratorError5 = undefined;\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfor (var _iterator5 = cells[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t\t\t\t\t\t\t\t\t\tvar _cell = _step5.value;\n\n\t\t\t\t\t\t\t\t\t\tthis.DrawCellFrom(_cell, openings[loopDirIndex], 1);\n\n\t\t\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t_didIteratorError5 = true;\n\t\t\t\t\t\t\t\t\t_iteratorError5 = err;\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t\t\t\t\t\t\t\t\t\t\t_iterator5.return();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\tif (_didIteratorError5) {\n\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError5;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion6 = true;\n\t\t\t\t\t\t\t\tvar _didIteratorError6 = false;\n\t\t\t\t\t\t\t\tvar _iteratorError6 = undefined;\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfor (var _iterator6 = crossings[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t\t\t\t\t\t\t\t\t\tvar _cell2 = _step6.value;\n\n\t\t\t\t\t\t\t\t\t\tthis.DrawWallTo(_cell2, openings[cornerDirIndex], 1);\n\t\t\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\n\t\t\t\t\t\t\t\t\t\tthis.DrawCellFrom(_cell2, openings[loopDirIndex], 1);\n\n\t\t\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t_didIteratorError6 = true;\n\t\t\t\t\t\t\t\t\t_iteratorError6 = err;\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t\t\t\t\t\t\t\t\t\t\t_iterator6.return();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\tif (_didIteratorError6) {\n\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar newStartCell = { x: startCell.x + openings[cornerDirIndex].x, y: startCell.y + openings[cornerDirIndex].y };\n\n\t\t\t\t\t\t\t\tthis.DrawWallTo(newStartCell, openings[loopDirIndex], 0);\n\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\n\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion7 = true;\n\t\t\t\t\t\t\t\tvar _didIteratorError7 = false;\n\t\t\t\t\t\t\t\tvar _iteratorError7 = undefined;\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfor (var _iterator7 = cells[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t\t\t\t\t\t\t\t\t\tvar _cell3 = _step7.value;\n\n\t\t\t\t\t\t\t\t\t\tvar newCell = { x: _cell3.x + openings[cornerDirIndex].x, y: _cell3.y + openings[cornerDirIndex].y };\n\n\t\t\t\t\t\t\t\t\t\tthis.DrawCellFrom(newCell, openings[loopDirIndex], 0);\n\t\t\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t_didIteratorError7 = true;\n\t\t\t\t\t\t\t\t\t_iteratorError7 = err;\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t\t\t\t\t\t\t\t\t\t\t_iterator7.return();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\tif (_didIteratorError7) {\n\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError7;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion8 = true;\n\t\t\t\t\t\t\t\tvar _didIteratorError8 = false;\n\t\t\t\t\t\t\t\tvar _iteratorError8 = undefined;\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfor (var _iterator8 = crossings[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n\t\t\t\t\t\t\t\t\t\tvar _cell4 = _step8.value;\n\n\t\t\t\t\t\t\t\t\t\tvar newCell = { x: _cell4.x + openings[cornerDirIndex].x, y: _cell4.y + openings[cornerDirIndex].y };\n\n\t\t\t\t\t\t\t\t\t\tthis.DrawWallTo(newCell, openings[loopDirIndex], 0);\n\t\t\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t_didIteratorError8 = true;\n\t\t\t\t\t\t\t\t\t_iteratorError8 = err;\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion8 && _iterator8.return) {\n\t\t\t\t\t\t\t\t\t\t\t_iterator8.return();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\tif (_didIteratorError8) {\n\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError8;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"RemoveExcessWall\",\n\t\tvalue: function RemoveExcessWall() {\n\t\t\tvar hasExcess = true;\n\n\t\t\twhile (hasExcess) {\n\t\t\t\thasExcess = false;\n\t\t\t\tfor (var x = 0; x < this.virtualGrid.length; x++) {\n\t\t\t\t\tfor (var y = 0; y < this.virtualGrid[x].length; y++) {\n\t\t\t\t\t\tif (this.virtualGrid[x][y] === 1) {\n\t\t\t\t\t\t\tvar cell = { x: x, y: y };\n\t\t\t\t\t\t\tvar directions = this.GetDirections(cell, 0);;\n\t\t\t\t\t\t\tif (directions.length >= 3) {\n\t\t\t\t\t\t\t\tthis.DrawCell(cell, 0);\n\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\t\t\t\t\t\t\t\thasExcess = true;\n\n\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion9 = true;\n\t\t\t\t\t\t\t\tvar _didIteratorError9 = false;\n\t\t\t\t\t\t\t\tvar _iteratorError9 = undefined;\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfor (var _iterator9 = directions[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n\t\t\t\t\t\t\t\t\t\tvar dir = _step9.value;\n\n\t\t\t\t\t\t\t\t\t\tif (!this.IsInRoom(x + dir.x, y + dir.y)) {\n\t\t\t\t\t\t\t\t\t\t\tthis.DrawWallTo(cell, dir, 0);\n\t\t\t\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t_didIteratorError9 = true;\n\t\t\t\t\t\t\t\t\t_iteratorError9 = err;\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion9 && _iterator9.return) {\n\t\t\t\t\t\t\t\t\t\t\t_iterator9.return();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\tif (_didIteratorError9) {\n\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError9;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"RemoveArtifacts\",\n\t\tvalue: function RemoveArtifacts() {\n\t\t\tfor (var x = 0; x < this.grid.length - this.wallWidth; x += this.wallWidth + this.mazeWidth) {\n\t\t\t\tfor (var y = 0; y < this.grid[x].length - this.wallWidth; y += this.wallWidth + this.mazeWidth) {\n\t\t\t\t\tif (x - 1 < 0 || y - 1 < 0 || x + this.wallWidth >= this.grid.length || y + this.wallWidth >= this.grid[x].length) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.grid[x - 1][y] === 0 && this.grid[x][y - 1] === 0 && this.grid[x + this.wallWidth][y] === 0 && this.grid[x][y + this.wallWidth] === 0) {\n\t\t\t\t\t\tfor (var i = x; i < x + this.wallWidth; i++) {\n\t\t\t\t\t\t\tfor (var j = y; j < y + this.wallWidth; j++) {\n\t\t\t\t\t\t\t\tthis.grid[i][j] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.UpdateFrame();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"RemoveDeadEnds\",\n\t\tvalue: function RemoveDeadEnds() {\n\t\t\tvar hasDeadEnds = true;\n\n\t\t\twhile (hasDeadEnds) {\n\t\t\t\thasDeadEnds = false;\n\t\t\t\tfor (var x = 0; x < this.virtualGrid.length; x++) {\n\t\t\t\t\tfor (var y = 0; y < this.virtualGrid[x].length; y++) {\n\t\t\t\t\t\tif (this.virtualGrid[x][y] === 0) {\n\t\t\t\t\t\t\tvar cell = { x: x, y: y };\n\t\t\t\t\t\t\tvar walls = this.CellWalls(cell, 0);\n\t\t\t\t\t\t\tif (walls.length === 1) {\n\t\t\t\t\t\t\t\tthis.DrawCellFrom(cell, walls[0], 1);\n\t\t\t\t\t\t\t\tthis.UpdateFrame();\n\t\t\t\t\t\t\t\thasDeadEnds = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"RemoveMazeWalls\",\n\t\tvalue: function RemoveMazeWalls() {\n\t\t\tvar _this = this;\n\n\t\t\tfor (var x = 0; x < this.virtualGrid.length; x++) {\n\t\t\t\tfor (var y = 0; y < this.virtualGrid.length; y++) {\n\t\t\t\t\tif (this.virtualGrid[x][y] === 0) {\n\t\t\t\t\t\tvar _ret = function () {\n\t\t\t\t\t\t\tif (_this.IsInRoom(x, y)) {\n\t\t\t\t\t\t\t\treturn \"continue\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar cell = { x: x, y: y };\n\n\t\t\t\t\t\t\tvar directions = _this.GetDirections(cell, 0);\n\t\t\t\t\t\t\tvar walls = _this.CellWalls(cell, 1);\n\n\t\t\t\t\t\t\tvar validDirections = directions.filter(function (d) {\n\t\t\t\t\t\t\t\treturn walls.some(function (w) {\n\t\t\t\t\t\t\t\t\treturn d.x === w.x && d.y === w.y;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tvar _iteratorNormalCompletion10 = true;\n\t\t\t\t\t\t\tvar _didIteratorError10 = false;\n\t\t\t\t\t\t\tvar _iteratorError10 = undefined;\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfor (var _iterator10 = validDirections[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n\t\t\t\t\t\t\t\t\tvar dir = _step10.value;\n\n\t\t\t\t\t\t\t\t\tif (!_this.IsInRoom(x + dir.x, y + dir.y)) {\n\t\t\t\t\t\t\t\t\t\t_this.DrawWallTo(cell, dir, 0);\n\t\t\t\t\t\t\t\t\t\t_this.UpdateFrame();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t_didIteratorError10 = true;\n\t\t\t\t\t\t\t\t_iteratorError10 = err;\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion10 && _iterator10.return) {\n\t\t\t\t\t\t\t\t\t\t_iterator10.return();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\tif (_didIteratorError10) {\n\t\t\t\t\t\t\t\t\t\tthrow _iteratorError10;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}();\n\n\t\t\t\t\t\tif (_ret === \"continue\") continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"IsInRoom\",\n\t\tvalue: function IsInRoom(x, y) {\n\t\t\tif (!this.rooms) return false;\n\n\t\t\tvar isInRoom = false;\n\t\t\tvar _iteratorNormalCompletion11 = true;\n\t\t\tvar _didIteratorError11 = false;\n\t\t\tvar _iteratorError11 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator11 = this.rooms[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n\t\t\t\t\tvar room = _step11.value;\n\n\t\t\t\t\tif (room.x <= x && room.y <= y && room.xBorder > x && room.yBorder > y) {\n\t\t\t\t\t\tisInRoom = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError11 = true;\n\t\t\t\t_iteratorError11 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion11 && _iterator11.return) {\n\t\t\t\t\t\t_iterator11.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError11) {\n\t\t\t\t\t\tthrow _iteratorError11;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn isInRoom;\n\t\t}\n\t}, {\n\t\tkey: \"GetDirections\",\n\t\tvalue: function GetDirections(cell, value) {\n\t\t\tvar directions = [];\n\n\t\t\tvar up = { x: 0, y: -1 };\n\t\t\tvar down = { x: 0, y: 1 };\n\t\t\tvar left = { x: -1, y: 0 };\n\t\t\tvar right = { x: 1, y: 0 };\n\n\t\t\tif (this.IsDirValid(cell, up) && this.virtualGrid[cell.x + up.x][cell.y + up.y] === value) directions.push(up);\n\t\t\tif (this.IsDirValid(cell, down) && this.virtualGrid[cell.x + down.x][cell.y + down.y] === value) directions.push(down);\n\t\t\tif (this.IsDirValid(cell, left) && this.virtualGrid[cell.x + left.x][cell.y + left.y] === value) directions.push(left);\n\t\t\tif (this.IsDirValid(cell, right) && this.virtualGrid[cell.x + right.x][cell.y + right.y] === value) directions.push(right);\n\n\t\t\treturn directions;\n\t\t}\n\t}, {\n\t\tkey: \"IsDirValid\",\n\t\tvalue: function IsDirValid(cell, dir) {\n\t\t\treturn cell.x + dir.x >= 0 && cell.y + dir.y >= 0 && cell.x + dir.x < this.width && cell.y + dir.y < this.height;\n\t\t}\n\t}, {\n\t\tkey: \"CellWalls\",\n\t\tvalue: function CellWalls(cell, value) {\n\t\t\tvar x = this.wallWidth + cell.x * (this.wallWidth + this.mazeWidth);\n\t\t\tvar y = this.wallWidth + cell.y * (this.wallWidth + this.mazeWidth);\n\n\t\t\tvar xBorder = x + this.mazeWidth;\n\t\t\tvar yBorder = y + this.mazeWidth;\n\n\t\t\tvar walls = [];\n\n\t\t\tif (this.grid[x][y - 1] === value) {\n\t\t\t\twalls.push({ x: 0, y: -1 });\n\t\t\t}\n\t\t\tif (this.grid[x - 1][y] === value) {\n\t\t\t\twalls.push({ x: -1, y: 0 });\n\t\t\t}\n\t\t\tif (this.grid[x][yBorder] === value) {\n\t\t\t\twalls.push({ x: 0, y: 1 });\n\t\t\t}\n\t\t\tif (this.grid[xBorder][y] === value) {\n\t\t\t\twalls.push({ x: 1, y: 0 });\n\t\t\t}\n\n\t\t\treturn walls;\n\t\t}\n\t}, {\n\t\tkey: \"DrawRoom\",\n\t\tvalue: function DrawRoom(room) {\n\t\t\tvar x = this.wallWidth + room.x * (this.wallWidth + this.mazeWidth);\n\t\t\tvar y = this.wallWidth + room.y * (this.wallWidth + this.mazeWidth);\n\n\t\t\tvar xBorder = room.xBorder * (this.wallWidth + this.mazeWidth);\n\t\t\tvar yBorder = room.yBorder * (this.wallWidth + this.mazeWidth);\n\n\t\t\tfor (var ix = x; ix < xBorder; ix++) {\n\t\t\t\tfor (var iy = y; iy < yBorder; iy++) {\n\t\t\t\t\tthis.grid[ix][iy] = 0;\n\t\t\t\t}\n\t\t\t\tthis.UpdateFrame();\n\t\t\t}\n\n\t\t\tfor (var _ix = room.x; _ix < room.xBorder; _ix++) {\n\t\t\t\tfor (var _iy = room.y; _iy < room.yBorder; _iy++) {\n\t\t\t\t\tthis.virtualGrid[_ix][_iy] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"DrawCell\",\n\t\tvalue: function DrawCell(cell, value) {\n\t\t\tvar x = this.wallWidth + cell.x * (this.wallWidth + this.mazeWidth);\n\t\t\tvar y = this.wallWidth + cell.y * (this.wallWidth + this.mazeWidth);\n\n\t\t\tvar xBorder = x + this.mazeWidth;\n\t\t\tvar yBorder = y + this.mazeWidth;\n\n\t\t\tfor (var ix = x; ix < xBorder; ix++) {\n\t\t\t\tfor (var iy = y; iy < yBorder; iy++) {\n\t\t\t\t\tthis.grid[ix][iy] = value || 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.virtualGrid[cell.x][cell.y] = value || 0;\n\t\t}\n\t}, {\n\t\tkey: \"DrawWallTo\",\n\t\tvalue: function DrawWallTo(cell, dir, value) {\n\t\t\tvar cellXPosition = this.wallWidth + cell.x * (this.wallWidth + this.mazeWidth);\n\t\t\tvar cellYPosition = this.wallWidth + cell.y * (this.wallWidth + this.mazeWidth);\n\n\t\t\tvar gapStartX = cellXPosition + (dir.x === 1 ? this.mazeWidth : dir.x === -1 ? -this.wallWidth : 0);\n\t\t\tvar gapStartY = cellYPosition + (dir.y === 1 ? this.mazeWidth : dir.y === -1 ? -this.wallWidth : 0);\n\n\t\t\tfor (var x = gapStartX; x < gapStartX + Math.abs(dir.x) * this.wallWidth + Math.abs(dir.y) * this.mazeWidth; x++) {\n\t\t\t\tfor (var y = gapStartY; y < gapStartY + Math.abs(dir.y) * this.wallWidth + Math.abs(dir.x) * this.mazeWidth; y++) {\n\t\t\t\t\tthis.grid[x][y] = value || 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"DrawCellTo\",\n\t\tvalue: function DrawCellTo(cell, dir, value) {\n\t\t\tthis.DrawWallTo(cell, dir, value);\n\n\t\t\tthis.DrawCell({\n\t\t\t\tx: cell.x + dir.x,\n\t\t\t\ty: cell.y + dir.y\n\t\t\t}, value);\n\t\t}\n\t}, {\n\t\tkey: \"DrawCellFrom\",\n\t\tvalue: function DrawCellFrom(cell, dir, value) {\n\t\t\tthis.DrawWallTo(cell, dir, value);\n\n\t\t\tthis.DrawCell(cell, value);\n\t\t}\n\t}]);\n\n\treturn LevelGenerator;\n}();\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGV2ZWxHZW5lcmF0b3IuanM/Y2RiNiJdLCJuYW1lcyI6WyJyYW5kb20iLCJtaW4iLCJtYXgiLCJNYXRoIiwiZmxvb3IiLCJMZXZlbEdlbmVyYXRvciIsIm9wdGlvbnMiLCJzZWVkIiwiZ2xvYmFsIiwid2lkdGgiLCJoZWlnaHQiLCJyb29tQXR0ZW1wdHMiLCJtYXhTaXplIiwibWluU2l6ZSIsIndpbmR5bmVzcyIsIndhbGxXaWR0aCIsIm1hemVXaWR0aCIsIm1pbkRvb3JzIiwibWF4RG9vcnMiLCJhbmltYXRlIiwiYW5pbWF0aW9uRGVsYXkiLCJ1cGRhdGVGcmFtZSIsIkluaXRHcmlkIiwiY29uc29sZSIsImxvZyIsIkFkZFJvb21zIiwiQ3JlYXRlTWF6ZSIsIk9wZW5Sb29tcyIsIlJlbW92ZURlYWRFbmRzIiwiUmVkdWNlU2xhY2siLCJSZW1vdmVNYXplV2FsbHMiLCJSZW1vdmVFeGNlc3NXYWxsIiwiUmVtb3ZlQXJ0aWZhY3RzIiwiRmluYWxGcmFtZSIsImdyaWQiLCJzdGFydCIsIkRhdGUiLCJnZXRUaW1lIiwiZW5kIiwidmlydHVhbEdyaWQiLCJhY3R1YWxXaWR0aCIsImFjdHVhbEhlaWdodCIsImkiLCJqIiwicm9vbXMiLCJyb29tV2lkdGgiLCJyb29tSGVpZ2h0IiwieCIsInkiLCJ4Qm9yZGVyIiwieUJvcmRlciIsIm92ZXJsYXBzIiwicm9vbSIsIm5ld1Jvb20iLCJwdXNoIiwiRHJhd1Jvb20iLCJjZWxscyIsImxhc3REaXIiLCJzdGFydGluZ0NlbGwiLCJEcmF3Q2VsbCIsImxlbmd0aCIsImNlbGwiLCJkaXJlY3Rpb25zIiwiR2V0RGlyZWN0aW9ucyIsImRpciIsImhhc0xhc3QiLCJzb21lIiwiaW5kZXgiLCJEcmF3Q2VsbFRvIiwiVXBkYXRlRnJhbWUiLCJwb3AiLCJhbGxEaXJlY3Rpb25zIiwibWF4RG9vcnNBY3R1YWwiLCJudW1Eb29ycyIsImluZGV4ZXMiLCJuZXdSYW5kb20iLCJpbmNsdWRlcyIsIkRyYXdXYWxsVG8iLCJzbGFja0xlZnQiLCJzdGFydENlbGwiLCJlbmRDZWxsIiwidW5kZWZpbmVkIiwib3BlbmluZ3MiLCJDZWxsV2FsbHMiLCJhYnMiLCJpbkxvb3AiLCJvZmZzZXQiLCJjcm9zc2luZ3MiLCJsb29wRGlySW5kZXgiLCJjb3JuZXJEaXJJbmRleCIsImZpcnN0QXR0ZW1wdCIsImlzVmFsaWQiLCJ4RGlmZiIsInlEaWZmIiwibmV4dENlbGwiLCJuZXh0T3BlbmluZ3MiLCJpc1ZhbGlkQ3Jvc3NpbmciLCJldmVyeSIsIm8iLCJpc09ic3RydWN0ZWQiLCJzdGFydEluc2lkZUNlbGwiLCJzdGFydEluc2lkZVdhbGxzIiwidyIsIkRyYXdDZWxsRnJvbSIsIm5ld1N0YXJ0Q2VsbCIsIm5ld0NlbGwiLCJoYXNFeGNlc3MiLCJJc0luUm9vbSIsImhhc0RlYWRFbmRzIiwid2FsbHMiLCJ2YWxpZERpcmVjdGlvbnMiLCJmaWx0ZXIiLCJkIiwiaXNJblJvb20iLCJ2YWx1ZSIsInVwIiwiZG93biIsImxlZnQiLCJyaWdodCIsIklzRGlyVmFsaWQiLCJpeCIsIml5IiwiY2VsbFhQb3NpdGlvbiIsImNlbGxZUG9zaXRpb24iLCJnYXBTdGFydFgiLCJnYXBTdGFydFkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQUVBLElBQUlBLFNBQVMsU0FBVEEsTUFBUyxDQUFDQyxHQUFELEVBQU1DLEdBQU4sRUFBYztBQUMxQixRQUFPQyxLQUFLQyxLQUFMLENBQVdELEtBQUtILE1BQUwsTUFBaUJFLE1BQU1ELEdBQU4sR0FBWSxDQUE3QixDQUFYLElBQThDQSxHQUFyRDtBQUNBLENBRkQ7O0lBSWFJLGMsV0FBQUEsYztBQUNYLHlCQUFZQyxPQUFaLEVBQXFCO0FBQUE7O0FBQ3BCLE1BQUlBLFFBQVFDLElBQVosRUFBa0I7QUFDakIsNkJBQVdELFFBQVFDLElBQW5CLEVBQXlCLEVBQUVDLFFBQVEsSUFBVixFQUF6QjtBQUNBOztBQUVELE9BQUtDLEtBQUwsR0FBYUgsUUFBUUcsS0FBUixJQUFpQixFQUE5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QUFJNkUsU0FBYixFQUF3QjdFLElBQUk2RSxZQUFhMUgsS0FBS2lGLEdBQUwsQ0FBU3BCLElBQUloQixDQUFiLElBQWtCLEtBQUtqQyxTQUFwQyxHQUFrRFosS0FBS2lGLEdBQUwsQ0FBU3BCLElBQUlqQixDQUFiLElBQWtCLEtBQUsvQixTQUFyRyxFQUFpSGdDLEdBQWpILEVBQXNIO0FBQ3JILFVBQUtkLElBQUwsQ0FBVWEsQ0FBVixFQUFhQyxDQUFiLElBQWtCa0UsU0FBUyxDQUEzQjtBQUNBO0FBQ0Q7QUFDRDs7OzZCQUNVckQsSSxFQUFNRyxHLEVBQUtrRCxLLEVBQU87QUFDNUIsUUFBS3JDLFVBQUwsQ0FBZ0JoQixJQUFoQixFQUFzQkcsR0FBdEIsRUFBMkJrRCxLQUEzQjs7QUFFQSxRQUFLdkQsUUFBTCxDQUFjO0FBQ2JaLE9BQUdjLEtBQUtkLENBQUwsR0FBU2lCLElBQUlqQixDQURIO0FBRWJDLE9BQUdhLEtBQUtiLENBQUwsR0FBU2dCLElBQUloQjtBQUZILElBQWQsRUFHR2tFLEtBSEg7QUFJQTs7OytCQUNZckQsSSxFQUFNRyxHLEVBQUtrRCxLLEVBQU87QUFDOUIsUUFBS3JDLFVBQUwsQ0FBZ0JoQixJQUFoQixFQUFzQkcsR0FBdEIsRUFBMkJrRCxLQUEzQjs7QUFFQSxRQUFLdkQsUUFBTCxDQUFjRSxJQUFkLEVBQW9CcUQsS0FBcEI7QUFDQSIsImZpbGUiOiJsZXZlbEdlbmVyYXRvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzZWVkcmFuZG9tIGZyb20gJ3NlZWRyYW5kb20nXHJcblxyXG5sZXQgcmFuZG9tID0gKG1pbiwgbWF4KSA9PiB7XHJcblx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMZXZlbEdlbmVyYXRvciB7XHJcblx0IGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuXHQgXHRpZiAob3B0aW9ucy5zZWVkKSB7XHJcblx0XHQgXHRzZWVkcmFuZG9tKG9wdGlvbnMuc2VlZCwgeyBnbG9iYWw6IHRydWV9KTtcclxuXHQgXHR9XHJcblxyXG5cdCBcdHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDI1O1xyXG5cdCBcdHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgMjU7XHJcblx0IFx0dGhpcy5yb29tQXR0ZW1wdHMgPSBvcHRpb25zLnJvb21BdHRlbXB0cyB8fCA1MDtcclxuXHRcdHRoaXMubWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZSB8fCA4O1xyXG5cdFx0dGhpcy5taW5TaXplID0gb3B0aW9ucy5taW5TaXplIHx8IDU7XHJcblx0XHR0aGlzLndpbmR5bmVzcyA9IG9wdGlvbnMud2luZHluZXNzIHx8IDEwMDtcclxuXHRcdHRoaXMud2FsbFdpZHRoID0gb3B0aW9ucy53YWxsV2lkdGggfHwgMTtcclxuXHRcdHRoaXMubWF6ZVdpZHRoID0gb3B0aW9ucy5tYXplV2lkdGggfHwgMjtcclxuXHRcdHRoaXMubWluRG9vcnMgPSBvcHRpb25zLm1pbkRvb3JzIHx8IDE7XHJcblx0XHR0aGlzLm1heERvb3JzID0gb3B0aW9ucy5tYXhEb29ycyB8fCA0O1xyXG5cdFx0dGhpcy5hbmltYXRlID0gb3B0aW9ucy5hbmltYXRlIHx8IGZhbHNlO1xyXG5cdFx0dGhpcy5hbmltYXRpb25EZWxheSA9IG9wdGlvbnMuYW5pbWF0aW9uRGVsYXkgfHwgMTA7XHJcblx0IH1cclxuXHQgR2VuZXJhdGUodXBkYXRlRnJhbWUpIHtcclxuXHQgXHR0aGlzLnVwZGF0ZUZyYW1lID0gdXBkYXRlRnJhbWU7XHJcblxyXG5cdCBcdHRoaXMuSW5pdEdyaWQoKTtcclxuXHJcblx0IFx0Y29uc29sZS5sb2coXCJBZGRpbmcgcm9vbXMuLi5cIik7XHJcblxyXG5cdFx0dGhpcy5BZGRSb29tcygpO1xyXG5cclxuXHRcdGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgbWF6ZS4uLlwiKTtcclxuXHRcdFxyXG5cdFx0dGhpcy5DcmVhdGVNYXplKDAsIDApO1xyXG5cclxuXHRcdGNvbnNvbGUubG9nKFwiT3BlbmluZyByb29tcy4uLlwiKTtcclxuXHJcblx0XHR0aGlzLk9wZW5Sb29tcygpO1xyXG5cclxuXHRcdGNvbnNvbGUubG9nKFwiUmVtb3ZpbmcgZGVhZCBlbmRzLi4uXCIpO1xyXG5cclxuXHRcdHRoaXMuUmVtb3ZlRGVhZEVuZHMoKTtcclxuXHJcblx0XHRjb25zb2xlLmxvZyhcIlJlbW92aW5nIHNsYWNrLi4uXCIpO1xyXG5cclxuXHRcdHRoaXMuUmVkdWNlU2xhY2soKTtcclxuXHJcblx0XHRjb25zb2xlLmxvZyhcIlJlbW92aW5nIG1hemUgd2FsbHMuLi5cIik7XHJcblxyXG5cdFx0dGhpcy5SZW1vdmVNYXplV2FsbHMoKTtcclxuXHJcblx0XHRjb25zb2xlLmxvZyhcIlJlbW92aW5nIGV4Y2VzcyB3YWxscy4uLlwiKTtcclxuXHJcblx0XHR0aGlzLlJlbW92ZUV4Y2Vzc1dhbGwoKTtcclxuXHJcblx0XHRjb25zb2xlLmxvZyhcIlJlbW92aW5nIGFydGlmYWN0cy4uLlwiKTtcclxuXHJcblx0XHR0aGlzLlJlbW92ZUFydGlmYWN0cygpO1xyXG5cclxuXHRcdHRoaXMuRmluYWxGcmFtZSgpO1xyXG5cdCB9XHJcblx0IFVwZGF0ZUZyYW1lKCkge1xyXG5cdCBcdGlmICh0aGlzLnVwZGF0ZUZyYW1lICYmIHRoaXMuYW5pbWF0ZSkge1xyXG5cdCBcdFx0dGhpcy51cGRhdGVGcmFtZSh0aGlzLmdyaWQpO1xyXG5cclxuXHRcdFx0dmFyIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblx0XHRcdHZhciBlbmQgPSBzdGFydDtcclxuXHRcdFx0d2hpbGUoZW5kIDwgc3RhcnQgKyB0aGlzLmFuaW1hdGlvbkRlbGF5KSB7XHJcblx0XHRcdFx0ZW5kID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblx0XHRcdH1cclxuXHRcdCB9XHJcblx0IH1cclxuXHQgRmluYWxGcmFtZSgpIHtcclxuXHQgXHRpZiAodGhpcy51cGRhdGVGcmFtZSkge1xyXG5cdCBcdFx0dGhpcy51cGRhdGVGcmFtZSh0aGlzLmdyaWQpO1xyXG5cdCBcdH1cclxuXHQgfVxyXG5cdCBJbml0R3JpZCgpIHtcclxuXHQgXHR0aGlzLmdyaWQgPSBbXTtcclxuXHQgXHR0aGlzLnZpcnR1YWxHcmlkID0gW107XHJcblxyXG5cdCBcdGxldCBhY3R1YWxXaWR0aCA9IHRoaXMud2FsbFdpZHRoICsgdGhpcy53aWR0aCAqICh0aGlzLndhbGxXaWR0aCArIHRoaXMubWF6ZVdpZHRoKTtcclxuXHQgXHRsZXQgYWN0dWFsSGVpZ2h0ID0gdGhpcy53YWxsV2lkdGggKyB0aGlzLmhlaWdodCAqICh0aGlzLndhbGxXaWR0aCArIHRoaXMubWF6ZVdpZHRoKTtcclxuXHJcblx0IFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndpZHRoIDsgaSsrKSB7XHJcblx0XHRcdHRoaXMudmlydHVhbEdyaWRbaV0gPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmhlaWdodDsgaisrKSB7XHJcblx0XHRcdFx0dGhpcy52aXJ0dWFsR3JpZFtpXVtqXSA9IDE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFjdHVhbFdpZHRoIDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZ3JpZFtpXSA9IFtdO1xyXG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGFjdHVhbEhlaWdodDsgaisrKSB7XHJcblx0XHRcdFx0dGhpcy5ncmlkW2ldW2pdID0gMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdCB9XHJcblx0IEFkZFJvb21zKCkge1xyXG5cdCBcdHRoaXMucm9vbXMgPSBbXTtcclxuXHJcblx0IFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvb21BdHRlbXB0czsgaSsrKSB7XHJcblx0IFx0XHRsZXQgcm9vbVdpZHRoID0gcmFuZG9tKHRoaXMubWluU2l6ZSwgdGhpcy5tYXhTaXplKTtcclxuXHQgXHRcdGxldCByb29tSGVpZ2h0ID0gcmFuZG9tKHRoaXMubWluU2l6ZSwgdGhpcy5tYXhTaXplKTtcclxuXHJcblx0IFx0XHRsZXQgeCA9IHJhbmRvbSgxLCB0aGlzLndpZHRoIC0gcm9vbVdpZHRoIC0gMSk7XHJcblx0IFx0XHRsZXQgeSA9IHJhbmRvbSgxLCB0aGlzLmhlaWdodCAtIHJvb21IZWlnaHQgLSAxKTtcclxuXHJcblx0IFx0XHRsZXQgeEJvcmRlciA9IHggKyByb29tV2lkdGg7XHJcblx0XHRcdGxldCB5Qm9yZGVyID0geSArIHJvb21IZWlnaHQ7XHJcblxyXG5cdFx0XHRsZXQgb3ZlcmxhcHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdGZvciAobGV0IHJvb20gb2YgdGhpcy5yb29tcykge1xyXG5cdFx0XHRcdGlmIChyb29tLnggPD0geEJvcmRlclxyXG5cdFx0XHRcdFx0JiYgcm9vbS54Qm9yZGVyID49IHhcclxuXHRcdFx0XHRcdCYmIHJvb20ueSA8PSB5Qm9yZGVyXHJcblx0XHRcdFx0XHQmJiByb29tLnlCb3JkZXIgPj0geSkge1xyXG5cdFx0XHRcdCAgb3ZlcmxhcHMgPSB0cnVlO1xyXG5cdFx0XHRcdCAgYnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihvdmVybGFwcykgY29udGludWU7XHJcblxyXG5cdFx0XHRsZXQgbmV3Um9vbSA9IHtcclxuXHRcdFx0XHR4OiB4LFxyXG5cdFx0XHRcdHk6IHksXHJcblx0XHRcdFx0eEJvcmRlcjogeEJvcmRlcixcclxuXHRcdFx0XHR5Qm9yZGVyOiB5Qm9yZGVyXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR0aGlzLnJvb21zLnB1c2gobmV3Um9vbSk7XHJcblx0XHRcdHRoaXMuRHJhd1Jvb20obmV3Um9vbSlcclxuXHQgXHR9XHJcblx0IH1cclxuXHQgQ3JlYXRlTWF6ZSh4LCB5KSB7XHJcblx0XHRsZXQgY2VsbHMgPSBbXTtcclxuXHRcdGxldCBsYXN0RGlyO1xyXG5cclxuXHRcdGxldCBzdGFydGluZ0NlbGwgPSB7XHJcblx0XHRcdHg6IHgsXHJcblx0XHRcdHk6IHlcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLkRyYXdDZWxsKHN0YXJ0aW5nQ2VsbCk7XHJcblxyXG5cdFx0Y2VsbHMucHVzaChzdGFydGluZ0NlbGwpO1xyXG5cclxuXHRcdHdoaWxlKGNlbGxzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0bGV0IGNlbGwgPSBjZWxsc1tjZWxscy5sZW5ndGggLSAxXTtcclxuXHJcblx0XHRcdGxldCBkaXJlY3Rpb25zID0gdGhpcy5HZXREaXJlY3Rpb25zKGNlbGwsIDEpO1xyXG5cclxuXHRcdFx0aWYgKGRpcmVjdGlvbnMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGxldCBkaXI7XHJcblxyXG5cdFx0XHRcdGxldCBoYXNMYXN0ID0gISFsYXN0RGlyICYmIGRpcmVjdGlvbnMuc29tZSgoZGlyKSA9PiB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZGlyLnggPT09IGxhc3REaXIueCAmJiBkaXIueSA9PT0gbGFzdERpci55O1xyXG5cdFx0XHRcdH0pXHJcblxyXG5cdFx0XHRcdGlmIChoYXNMYXN0ICYmIHJhbmRvbSgwLCAxMDApID4gdGhpcy53aW5keW5lc3MpIHtcclxuXHRcdFx0XHRcdGRpciA9IGxhc3REaXI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGxldCBpbmRleCA9IHJhbmRvbSgwLCBkaXJlY3Rpb25zLmxlbmd0aCAtIDEpO1xyXG5cdFx0XHRcdFx0ZGlyID0gZGlyZWN0aW9uc1tpbmRleF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLkRyYXdDZWxsVG8oY2VsbCwgZGlyKTtcclxuXHJcblx0XHRcdFx0dGhpcy5VcGRhdGVGcmFtZSgpO1xyXG5cclxuXHRcdFx0XHRjZWxscy5wdXNoKHtcclxuXHRcdFx0XHRcdHg6IGNlbGwueCArIGRpci54LFxyXG5cdFx0XHRcdFx0eTogY2VsbC55ICsgZGlyLnlcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0bGFzdERpciA9IGRpcjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBSZW1vdmUgbGFzdCBjZWxsIGluIHRoZSBjdXJyZW50IGJyYW5jaFxyXG5cdFx0XHRcdGxhc3REaXIgPSBudWxsO1xyXG5cdFx0XHRcdGNlbGxzLnBvcCgpO1xyXG5cdFx0XHR9XHJcblx0ICAgIH1cclxuXHQgfVxyXG5cdCBPcGVuUm9vbXMoKSB7XHJcblx0IFx0aWYgKCF0aGlzLnJvb21zKSByZXR1cm47XHJcblxyXG5cdCBcdGZvcihsZXQgcm9vbSBvZiB0aGlzLnJvb21zKSB7XHJcblx0XHRcdGxldCBhbGxEaXJlY3Rpb25zID0gW107XHJcblx0XHRcdGFsbERpcmVjdGlvbnMucHVzaCh7IHg6IDAsIHk6IC0xIH0pO1xyXG5cdFx0XHRhbGxEaXJlY3Rpb25zLnB1c2goeyB4OiAwLCB5OiAxIH0pO1xyXG5cdFx0XHRhbGxEaXJlY3Rpb25zLnB1c2goeyB4OiAtMSwgeTogMCB9KTtcclxuXHRcdFx0YWxsRGlyZWN0aW9ucy5wdXNoKHsgeDogMSwgeTogMCB9KTtcclxuXHJcblx0XHRcdGxldCBtYXhEb29yc0FjdHVhbCA9IHRoaXMubWF4RG9vcnMgPCA0ID8gdGhpcy5tYXhEb29ycyA6IDQ7XHJcblx0XHRcdGxldCBudW1Eb29ycyA9IHJhbmRvbSh0aGlzLm1pbkRvb3JzLCBtYXhEb29yc0FjdHVhbCk7XHJcblxyXG5cdFx0XHRsZXQgZGlyZWN0aW9ucyA9IFtdO1xyXG5cdFx0XHRsZXQgaW5kZXhlcyA9IFtdO1xyXG5cclxuXHRcdFx0d2hpbGUgKGRpcmVjdGlvbnMubGVuZ3RoIDwgbnVtRG9vcnMpIHtcclxuXHRcdFx0XHRsZXQgbmV3UmFuZG9tID0gcmFuZG9tKDAsIDMpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWluZGV4ZXMuaW5jbHVkZXMobmV3UmFuZG9tKSkge1xyXG5cdFx0XHRcdFx0aW5kZXhlcy5wdXNoKG5ld1JhbmRvbSk7XHJcblx0XHRcdFx0XHRkaXJlY3Rpb25zLnB1c2goYWxsRGlyZWN0aW9uc1tuZXdSYW5kb21dKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAobGV0IGRpciBvZiBkaXJlY3Rpb25zKSB7XHJcblx0XHRcdFx0dmFyIHggPSBkaXIueCA9PT0gMSA/IHJvb20ueEJvcmRlciAtIDEgXHJcblx0XHRcdFx0XHRcdFx0OiBkaXIueCA9PT0gLTEgPyByb29tLnggXHJcblx0XHRcdFx0XHRcdFx0OiByYW5kb20ocm9vbS54ICsgMSwgcm9vbS54Qm9yZGVyIC0gMik7XHJcblxyXG5cdFx0XHRcdHZhciB5ID0gZGlyLnkgPT09IDEgPyByb29tLnlCb3JkZXIgLSAxIFxyXG5cdFx0XHRcdFx0XHRcdDogZGlyLnkgPT09IC0xID8gcm9vbS55IFxyXG5cdFx0XHRcdFx0XHRcdDogcmFuZG9tKHJvb20ueSArIDEsIHJvb20ueUJvcmRlciAtIDIpO1xyXG5cclxuXHRcdFx0XHR0aGlzLkRyYXdXYWxsVG8oe1xyXG5cdFx0XHRcdFx0eDogeCxcclxuXHRcdFx0XHRcdHk6IHlcclxuXHRcdFx0XHR9LCBkaXIsIDApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0IH1cclxuXHQgUmVkdWNlU2xhY2soKSB7XHJcblx0IFx0dmFyIHNsYWNrTGVmdCA9IHRydWU7XHJcblxyXG5cdCBcdHdoaWxlKHNsYWNrTGVmdCkge1xyXG5cdCBcdFx0c2xhY2tMZWZ0ID0gZmFsc2U7XHJcblxyXG5cdCBcdFx0Zm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnZpcnR1YWxHcmlkLmxlbmd0aDsgeCsrKSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnZpcnR1YWxHcmlkW3hdLmxlbmd0aDsgeSsrKSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy52aXJ0dWFsR3JpZFt4XVt5XSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgc3RhcnRDZWxsID0ge3g6IHgsIHk6IHl9O1xyXG5cdFx0XHRcdFx0XHR2YXIgZW5kQ2VsbCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdFx0dmFyIG9wZW5pbmdzID0gdGhpcy5DZWxsV2FsbHMoc3RhcnRDZWxsLCAwKTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIElzIHRoZSBjZWxsIGEgY29ybmVyXHJcblx0XHRcdFx0XHRcdGlmIChvcGVuaW5ncy5sZW5ndGggPT09IDIgJiYgTWF0aC5hYnMob3BlbmluZ3NbMF0ueCkgIT09IE1hdGguYWJzKG9wZW5pbmdzWzFdLngpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGluTG9vcCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG9mZnNldCA9IDE7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBjZWxscyA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjcm9zc2luZ3MgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGxvb3BEaXJJbmRleCA9IDA7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNvcm5lckRpckluZGV4ID0gMTtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGZpcnN0QXR0ZW1wdCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBpc1ZhbGlkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgY2VsbHMgaW4gc2xhY2sgdW50aWwgYSBjb3JuZXIgaXMgcmVhY2hlZFxyXG5cdFx0XHRcdFx0XHRcdHdoaWxlKGluTG9vcCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0bGV0IHhEaWZmID0gb3BlbmluZ3NbbG9vcERpckluZGV4XS54ICogb2Zmc2V0O1xyXG5cdFx0XHRcdFx0XHRcdFx0bGV0IHlEaWZmID0gb3BlbmluZ3NbbG9vcERpckluZGV4XS55ICogb2Zmc2V0O1xyXG5cdFx0XHRcdFx0XHRcdFx0bGV0IG5leHRDZWxsID0ge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR4OiB4ICsgeERpZmYsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHk6IHkgKyB5RGlmZlxyXG5cdFx0XHRcdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRsZXQgbmV4dE9wZW5pbmdzID0gdGhpcy5DZWxsV2FsbHMobmV4dENlbGwsIDApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIElmIHRoZSBjZWxsIGRvZXMgbm90IGhhdmUgMiBvciAzIG9wZW5pbmdzLCB0aGVuIGl0IGlzIG5vIGxvbmdlciBhIHNsYWNrXHJcblx0XHRcdFx0XHRcdFx0XHRpZihuZXh0T3BlbmluZ3MubGVuZ3RoID09PSAyKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElmIHRoZSBjZWxsIGlzIG5vdCBhIGNvcm5lciwgY29udGludWUgdG8gbmV4dCBjZWxsLlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnMobmV4dE9wZW5pbmdzWzBdLngpID09PSBNYXRoLmFicyhuZXh0T3BlbmluZ3NbMV0ueCkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXQrKztcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjZWxscy5wdXNoKG5leHRDZWxsKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZiB0aGUgY2VsbCBpcyBhIGNvcm5lciwgY2hlY2sgdGhhdCBpdHMgYSBjb3JuZXIgZmFjaW5nIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGUgc3RhcnQgY2VsbC5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoKG5leHRPcGVuaW5nc1sxXS54ID09IG9wZW5pbmdzW2Nvcm5lckRpckluZGV4XS54IHx8IG5leHRPcGVuaW5nc1swXS54ID09IG9wZW5pbmdzW2Nvcm5lckRpckluZGV4XS54KSBcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCYmIChuZXh0T3BlbmluZ3NbMV0ueSA9PSBvcGVuaW5nc1tjb3JuZXJEaXJJbmRleF0ueSB8fCBuZXh0T3BlbmluZ3NbMF0ueSA9PSBvcGVuaW5nc1tjb3JuZXJEaXJJbmRleF0ueSkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVuZENlbGwgPSBuZXh0Q2VsbDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIGNlbGwgaXMgYSBjb3JuZXIsIHRoZXJlIGlzIG5vIG1vcmUgY2VsbHMgdG8gbG9vcCBvdmVyXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5Mb29wID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobmV4dE9wZW5pbmdzLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgaXNWYWxpZENyb3NzaW5nID0gbmV4dE9wZW5pbmdzLmV2ZXJ5KChvKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChvLnggPT09IG9wZW5pbmdzW2Nvcm5lckRpckluZGV4XS54ICYmXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG8ueSA9PT0gb3BlbmluZ3NbY29ybmVyRGlySW5kZXhdLnkpIHx8XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvLnggPT09IG9wZW5pbmdzW2xvb3BEaXJJbmRleF0ueCAmJiBcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0by55ID09PSBvcGVuaW5nc1tsb29wRGlySW5kZXhdLnkpIHx8XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvLnggPT09IC1vcGVuaW5nc1tsb29wRGlySW5kZXhdLnggJiYgXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG8ueSA9PT0gLW9wZW5pbmdzW2xvb3BEaXJJbmRleF0ueSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGlzVmFsaWRDcm9zc2luZyl7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0b2Zmc2V0KytcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjcm9zc2luZ3MucHVzaChuZXh0Q2VsbCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5Mb29wID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpbkxvb3AgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIWluTG9vcCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgaXNPYnN0cnVjdGVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZW5kQ2VsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChjZWxscy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IgKGxldCBjZWxsIG9mIGNlbGxzKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLnZpcnR1YWxHcmlkW2NlbGwueCArIG9wZW5pbmdzW2Nvcm5lckRpckluZGV4XS54XVtjZWxsLnkgKyBvcGVuaW5nc1tjb3JuZXJEaXJJbmRleF0ueV0gPT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlzT2JzdHJ1Y3RlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIWlzT2JzdHJ1Y3RlZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpc1ZhbGlkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGV0IHN0YXJ0SW5zaWRlQ2VsbCA9IHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eDogeCArIG9wZW5pbmdzW2Nvcm5lckRpckluZGV4XS54LCBcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eTogeSArIG9wZW5pbmdzW2Nvcm5lckRpckluZGV4XS55XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGV0IHN0YXJ0SW5zaWRlV2FsbHMgPSB0aGlzLkNlbGxXYWxscyhzdGFydEluc2lkZUNlbGwsIDEpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlzT2JzdHJ1Y3RlZCA9ICFzdGFydEluc2lkZVdhbGxzLnNvbWUoKHcpID0+IHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHcueCA9PT0gb3BlbmluZ3NbbG9vcERpckluZGV4XS54ICYmIHcueSA9PT0gb3BlbmluZ3NbbG9vcERpckluZGV4XS55O1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFpc09ic3RydWN0ZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aXNWYWxpZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoKCFlbmRDZWxsIHx8IGlzT2JzdHJ1Y3RlZCkgJiYgZmlyc3RBdHRlbXB0KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5Mb29wID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaXJzdEF0dGVtcHQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgPSAxO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNlbGxzID0gW107XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZW5kQ2VsbCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjcm9zc2luZ3MgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bG9vcERpckluZGV4ID0gMTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb3JuZXJEaXJJbmRleCA9IDA7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICghaXNWYWxpZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRzbGFja0xlZnQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuRHJhd0NlbGxGcm9tKHN0YXJ0Q2VsbCwgb3BlbmluZ3NbY29ybmVyRGlySW5kZXhdLCAxKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5VcGRhdGVGcmFtZSgpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0aGlzLkRyYXdDZWxsRnJvbShlbmRDZWxsLCBvcGVuaW5nc1tjb3JuZXJEaXJJbmRleF0sIDEpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0aGlzLlVwZGF0ZUZyYW1lKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuRHJhd1dhbGxUbyhzdGFydENlbGwsIG9wZW5pbmdzW2xvb3BEaXJJbmRleF0sIDEpXHJcblxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuVXBkYXRlRnJhbWUoKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5EcmF3Q2VsbEZyb20oY2VsbCwgb3BlbmluZ3NbbG9vcERpckluZGV4XSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5VcGRhdGVGcmFtZSgpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBjZWxsIG9mIGNyb3NzaW5ncykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5EcmF3V2FsbFRvKGNlbGwsIG9wZW5pbmdzW2Nvcm5lckRpckluZGV4XSwgMSk7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLlVwZGF0ZUZyYW1lKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5EcmF3Q2VsbEZyb20oY2VsbCwgb3BlbmluZ3NbbG9vcERpckluZGV4XSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5VcGRhdGVGcmFtZSgpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBuZXdTdGFydENlbGwgPSB7IHg6IHN0YXJ0Q2VsbC54ICsgb3BlbmluZ3NbY29ybmVyRGlySW5kZXhdLngsIHk6IHN0YXJ0Q2VsbC55ICsgb3BlbmluZ3NbY29ybmVyRGlySW5kZXhdLnkgfVxyXG5cclxuXHRcdFx0XHRcdFx0XHR0aGlzLkRyYXdXYWxsVG8obmV3U3RhcnRDZWxsLCBvcGVuaW5nc1tsb29wRGlySW5kZXhdLCAwKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLlVwZGF0ZUZyYW1lKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBuZXdDZWxsID0geyB4OiBjZWxsLnggKyBvcGVuaW5nc1tjb3JuZXJEaXJJbmRleF0ueCwgeTogY2VsbC55ICsgb3BlbmluZ3NbY29ybmVyRGlySW5kZXhdLnkgfVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuRHJhd0NlbGxGcm9tKG5ld0NlbGwsIG9wZW5pbmdzW2xvb3BEaXJJbmRleF0sIDApO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5VcGRhdGVGcmFtZSgpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgY2VsbCBvZiBjcm9zc2luZ3MpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBuZXdDZWxsID0geyB4OiBjZWxsLnggKyBvcGVuaW5nc1tjb3JuZXJEaXJJbmRleF0ueCwgeTogY2VsbC55ICsgb3BlbmluZ3NbY29ybmVyRGlySW5kZXhdLnkgfVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuRHJhd1dhbGxUbyhuZXdDZWxsLCBvcGVuaW5nc1tsb29wRGlySW5kZXhdLCAwKTtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuVXBkYXRlRnJhbWUoKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHQgXHR9XHJcblx0IH1cclxuXHQgUmVtb3ZlRXhjZXNzV2FsbCgpIHtcclxuXHQgXHRsZXQgaGFzRXhjZXNzID0gdHJ1ZTtcclxuXHJcblx0XHR3aGlsZSAoaGFzRXhjZXNzKSB7XHJcblx0XHRcdGhhc0V4Y2VzcyA9IGZhbHNlO1xyXG5cdFx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMudmlydHVhbEdyaWQubGVuZ3RoOyB4KyspIHtcclxuXHRcdFx0XHRmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMudmlydHVhbEdyaWRbeF0ubGVuZ3RoOyB5KyspIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLnZpcnR1YWxHcmlkW3hdW3ldID09PSAxKSB7XHJcblx0XHRcdFx0XHRcdHZhciBjZWxsID0ge3g6IHgsIHk6IHl9O1xyXG5cdFx0XHRcdFx0XHR2YXIgZGlyZWN0aW9ucyA9IHRoaXMuR2V0RGlyZWN0aW9ucyhjZWxsLCAwKTs7XHJcblx0XHRcdFx0XHRcdGlmIChkaXJlY3Rpb25zLmxlbmd0aCA+PSAzKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5EcmF3Q2VsbChjZWxsLCAwKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLlVwZGF0ZUZyYW1lKCk7XHJcblx0XHRcdFx0XHRcdFx0aGFzRXhjZXNzID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgZGlyIG9mIGRpcmVjdGlvbnMpIHtcclxuXHRcdFx0XHQgXHRcdFx0XHRpZiAoIXRoaXMuSXNJblJvb20oeCArIGRpci54LCB5ICsgZGlyLnkpKVxyXG5cdFx0XHRcdCBcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5EcmF3V2FsbFRvKGNlbGwsIGRpciwgMCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuVXBkYXRlRnJhbWUoKTtcclxuXHRcdFx0XHQgXHRcdFx0XHR9XHJcblx0XHRcdFx0IFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdCB9XHJcblx0IFJlbW92ZUFydGlmYWN0cygpIHtcclxuXHQgXHRmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuZ3JpZC5sZW5ndGggLSB0aGlzLndhbGxXaWR0aDsgeCArPSB0aGlzLndhbGxXaWR0aCArIHRoaXMubWF6ZVdpZHRoKSB7XHJcblx0XHRcdGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5ncmlkW3hdLmxlbmd0aCAtIHRoaXMud2FsbFdpZHRoOyB5ICs9IHRoaXMud2FsbFdpZHRoICsgdGhpcy5tYXplV2lkdGgpIHtcclxuXHRcdFx0XHRpZiAoeCAtIDEgPCAwIFxyXG5cdFx0XHRcdFx0fHwgeSAtIDEgPCAwIFxyXG5cdFx0XHRcdFx0fHwgeCArIHRoaXMud2FsbFdpZHRoID49IHRoaXMuZ3JpZC5sZW5ndGggXHJcblx0XHRcdFx0XHR8fCB5ICsgdGhpcy53YWxsV2lkdGggPj0gdGhpcy5ncmlkW3hdLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5ncmlkW3gtMV1beV0gPT09IDAgXHJcblx0XHRcdFx0XHQmJiB0aGlzLmdyaWRbeF1beS0xXSA9PT0gMCBcclxuXHRcdFx0XHRcdCYmIHRoaXMuZ3JpZFt4ICsgdGhpcy53YWxsV2lkdGhdW3ldID09PSAwIFxyXG5cdFx0XHRcdFx0JiYgdGhpcy5ncmlkW3hdW3kgKyB0aGlzLndhbGxXaWR0aF0gPT09IDApIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSB4OyBpIDwgeCArIHRoaXMud2FsbFdpZHRoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IHk7IGogPCB5ICsgdGhpcy53YWxsV2lkdGg7IGorKykge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZ3JpZFtpXVtqXSA9IDA7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5VcGRhdGVGcmFtZSgpO1xyXG5cdFx0fVxyXG5cdCB9XHJcblx0IFJlbW92ZURlYWRFbmRzKCkge1xyXG5cdCBcdGxldCBoYXNEZWFkRW5kcyA9IHRydWU7XHJcblxyXG5cdFx0d2hpbGUgKGhhc0RlYWRFbmRzKSB7XHJcblx0XHRcdGhhc0RlYWRFbmRzID0gZmFsc2U7XHJcblx0XHRcdGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy52aXJ0dWFsR3JpZC5sZW5ndGg7IHgrKykge1xyXG5cdFx0XHRcdGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy52aXJ0dWFsR3JpZFt4XS5sZW5ndGg7IHkrKykge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMudmlydHVhbEdyaWRbeF1beV0gPT09IDApIHtcclxuXHRcdFx0XHRcdFx0dmFyIGNlbGwgPSB7eDogeCwgeTogeX07XHJcblx0XHRcdFx0XHRcdHZhciB3YWxscyA9IHRoaXMuQ2VsbFdhbGxzKGNlbGwsIDApO1xyXG5cdFx0XHRcdFx0XHRpZiAod2FsbHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5EcmF3Q2VsbEZyb20oY2VsbCwgd2FsbHNbMF0sIDEpO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuVXBkYXRlRnJhbWUoKTtcclxuXHRcdFx0XHRcdFx0XHRoYXNEZWFkRW5kcyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHQgfVxyXG5cdCBSZW1vdmVNYXplV2FsbHMoKSB7XHJcblx0IFx0Zm9yKGxldCB4ID0gMDsgeCA8IHRoaXMudmlydHVhbEdyaWQubGVuZ3RoOyB4KyspIHtcclxuXHQgXHRcdGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy52aXJ0dWFsR3JpZC5sZW5ndGg7IHkrKykge1xyXG5cdCBcdFx0XHRpZiAodGhpcy52aXJ0dWFsR3JpZFt4XVt5XSA9PT0gMCkge1xyXG5cdCBcdFx0XHRcdGlmICh0aGlzLklzSW5Sb29tKHgsIHkpKSB7XHJcblx0IFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHQgXHRcdFx0XHR9XHJcblxyXG5cdCBcdFx0XHRcdGxldCBjZWxsID0geyB4OiB4LCB5OiB5IH07XHJcblxyXG5cdFx0IFx0XHRcdGxldCBkaXJlY3Rpb25zID0gdGhpcy5HZXREaXJlY3Rpb25zKGNlbGwsIDApO1xyXG5cdFx0IFx0XHRcdGxldCB3YWxscyA9IHRoaXMuQ2VsbFdhbGxzKGNlbGwsIDEpO1xyXG5cclxuXHRcdCBcdFx0XHRsZXQgdmFsaWREaXJlY3Rpb25zID0gZGlyZWN0aW9ucy5maWx0ZXIoKGQpID0+IHtcclxuXHRcdCBcdFx0XHRcdHJldHVybiB3YWxscy5zb21lKCh3KSA9PiB7XHJcblx0XHQgXHRcdFx0XHRcdHJldHVybiBkLnggPT09IHcueCAmJiBkLnkgPT09IHcueTtcclxuXHRcdCBcdFx0XHRcdH0pO1xyXG5cdFx0IFx0XHRcdH0pO1xyXG5cclxuXHRcdCBcdFx0XHRmb3IgKGxldCBkaXIgb2YgdmFsaWREaXJlY3Rpb25zKSB7XHJcblx0XHQgXHRcdFx0XHRpZiAoIXRoaXMuSXNJblJvb20oeCArIGRpci54LCB5ICsgZGlyLnkpKVxyXG5cdFx0IFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuRHJhd1dhbGxUbyhjZWxsLCBkaXIsIDApO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuVXBkYXRlRnJhbWUoKTtcclxuXHRcdCBcdFx0XHRcdH1cclxuXHRcdCBcdFx0XHR9XHJcblx0IFx0XHRcdH1cclxuXHQgXHRcdH1cclxuXHQgXHR9XHJcblx0IH1cclxuXHQgSXNJblJvb20oeCwgeSkge1xyXG5cdCBcdGlmICghdGhpcy5yb29tcykgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHQgXHR2YXIgaXNJblJvb20gPSBmYWxzZTtcclxuXHRcdGZvciAobGV0IHJvb20gb2YgdGhpcy5yb29tcykge1xyXG5cdFx0XHRpZiAocm9vbS54IDw9IHggJiYgcm9vbS55IDw9IHkgJiYgcm9vbS54Qm9yZGVyID4geCAmJiByb29tLnlCb3JkZXIgPiB5KSB7XHJcblx0XHRcdFx0aXNJblJvb20gPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlzSW5Sb29tO1xyXG5cdCB9XHJcblx0IEdldERpcmVjdGlvbnMoY2VsbCwgdmFsdWUpIHtcclxuXHQgXHRsZXQgZGlyZWN0aW9ucyA9IFtdO1xyXG5cclxuXHQgXHRsZXQgdXAgPSB7IHg6IDAsIHk6IC0xIH07XHJcblx0XHRsZXQgZG93biA9IHsgeDogMCwgeTogMSB9O1xyXG5cdFx0bGV0IGxlZnQgPSB7IHg6IC0xLCB5OiAwIH07XHJcblx0XHRsZXQgcmlnaHQgPSB7IHg6IDEsIHk6IDAgfTtcclxuXHJcblx0XHRpZiAodGhpcy5Jc0RpclZhbGlkKGNlbGwsIHVwKSBcclxuXHRcdFx0JiYgdGhpcy52aXJ0dWFsR3JpZFtjZWxsLnggKyB1cC54XVtjZWxsLnkgKyB1cC55XSA9PT0gdmFsdWUpIFxyXG5cdFx0XHRkaXJlY3Rpb25zLnB1c2godXApO1xyXG5cdFx0aWYgKHRoaXMuSXNEaXJWYWxpZChjZWxsLCBkb3duKSBcclxuXHRcdFx0JiYgdGhpcy52aXJ0dWFsR3JpZFtjZWxsLnggKyBkb3duLnhdW2NlbGwueSArIGRvd24ueV0gPT09IHZhbHVlKSBcclxuXHRcdFx0ZGlyZWN0aW9ucy5wdXNoKGRvd24pO1xyXG5cdFx0aWYgKHRoaXMuSXNEaXJWYWxpZChjZWxsLCBsZWZ0KSBcclxuXHRcdFx0JiYgdGhpcy52aXJ0dWFsR3JpZFtjZWxsLnggKyBsZWZ0LnhdW2NlbGwueSArIGxlZnQueV0gPT09IHZhbHVlKSBcclxuXHRcdFx0ZGlyZWN0aW9ucy5wdXNoKGxlZnQpO1xyXG5cdFx0aWYgKHRoaXMuSXNEaXJWYWxpZChjZWxsLCByaWdodCkgXHJcblx0XHRcdCYmIHRoaXMudmlydHVhbEdyaWRbY2VsbC54ICsgcmlnaHQueF1bY2VsbC55ICsgcmlnaHQueV0gPT09IHZhbHVlKSBcclxuXHRcdFx0ZGlyZWN0aW9ucy5wdXNoKHJpZ2h0KTtcclxuXHJcblx0XHRyZXR1cm4gZGlyZWN0aW9ucztcclxuXHQgfVxyXG5cdCBJc0RpclZhbGlkKGNlbGwsIGRpcikge1xyXG5cdCBcdHJldHVybiBjZWxsLnggKyBkaXIueCA+PSAwIFxyXG5cdCBcdFx0JiYgY2VsbC55ICsgZGlyLnkgPj0gMFxyXG5cdCBcdFx0JiYgY2VsbC54ICsgZGlyLnggPCB0aGlzLndpZHRoXHJcblx0IFx0XHQmJiBjZWxsLnkgKyBkaXIueSA8IHRoaXMuaGVpZ2h0O1xyXG5cdCB9XHJcblx0IENlbGxXYWxscyhjZWxsLCB2YWx1ZSkge1xyXG5cdCBcdGxldCB4ID0gdGhpcy53YWxsV2lkdGggKyBjZWxsLnggKiAodGhpcy53YWxsV2lkdGggKyB0aGlzLm1hemVXaWR0aCk7XHJcblx0IFx0bGV0IHkgPSB0aGlzLndhbGxXaWR0aCArIGNlbGwueSAqICh0aGlzLndhbGxXaWR0aCArIHRoaXMubWF6ZVdpZHRoKTtcclxuXHJcblx0IFx0bGV0IHhCb3JkZXIgPSB4ICsgdGhpcy5tYXplV2lkdGg7XHJcblx0IFx0bGV0IHlCb3JkZXIgPSB5ICsgdGhpcy5tYXplV2lkdGg7XHJcblxyXG5cdCBcdGxldCB3YWxscyA9IFtdO1xyXG5cclxuXHQgXHRpZiAodGhpcy5ncmlkW3hdW3ktMV0gPT09IHZhbHVlKSB7XHJcblx0IFx0XHR3YWxscy5wdXNoKHt4OiAwLCB5OiAtMX0pO1xyXG5cdCBcdH1cclxuXHQgXHRpZiAodGhpcy5ncmlkW3ggLSAxXVt5XSA9PT0gdmFsdWUpIHtcclxuXHQgXHRcdHdhbGxzLnB1c2goe3g6IC0xLCB5OiAwfSk7XHJcblx0IFx0fVxyXG5cdCBcdGlmICh0aGlzLmdyaWRbeF1beUJvcmRlcl0gPT09IHZhbHVlKSB7XHJcblx0IFx0XHR3YWxscy5wdXNoKHt4OiAwLCB5OiAxfSk7XHJcblx0IFx0fVxyXG5cdCBcdGlmICh0aGlzLmdyaWRbeEJvcmRlcl1beV0gPT09IHZhbHVlKSB7XHJcblx0IFx0XHR3YWxscy5wdXNoKHt4OiAxLCB5OiAwfSk7XHJcblx0IFx0fVxyXG5cclxuXHQgXHRyZXR1cm4gd2FsbHM7XHJcblx0IH1cclxuXHQgRHJhd1Jvb20ocm9vbSkge1xyXG5cdCBcdGxldCB4ID0gdGhpcy53YWxsV2lkdGggKyByb29tLnggKiAodGhpcy53YWxsV2lkdGggKyB0aGlzLm1hemVXaWR0aCk7XHJcblx0IFx0bGV0IHkgPSB0aGlzLndhbGxXaWR0aCArIHJvb20ueSAqICh0aGlzLndhbGxXaWR0aCArIHRoaXMubWF6ZVdpZHRoKTtcclxuXHJcblx0IFx0bGV0IHhCb3JkZXIgPSByb29tLnhCb3JkZXIgKiAodGhpcy53YWxsV2lkdGggKyB0aGlzLm1hemVXaWR0aCk7XHJcblx0IFx0bGV0IHlCb3JkZXIgPSByb29tLnlCb3JkZXIgKiAodGhpcy53YWxsV2lkdGggKyB0aGlzLm1hemVXaWR0aCk7XHJcblxyXG5cdCBcdGZvciAobGV0IGl4ID0geDsgaXggPCB4Qm9yZGVyOyBpeCsrKSB7XHJcblx0XHRcdGZvciAobGV0IGl5ID0geTsgaXkgPCB5Qm9yZGVyOyBpeSsrKSB7XHJcblx0XHRcdFx0dGhpcy5ncmlkW2l4XVtpeV0gPSAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuVXBkYXRlRnJhbWUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpeCA9IHJvb20ueDsgaXggPCByb29tLnhCb3JkZXI7IGl4KyspIHtcclxuXHRcdFx0Zm9yIChsZXQgaXkgPSByb29tLnk7IGl5IDwgcm9vbS55Qm9yZGVyOyBpeSsrKSB7XHJcblx0XHRcdFx0dGhpcy52aXJ0dWFsR3JpZFtpeF1baXldID0gMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdCB9XHJcblx0IERyYXdDZWxsKGNlbGwsIHZhbHVlKSB7XHJcblx0IFx0bGV0IHggPSB0aGlzLndhbGxXaWR0aCArIGNlbGwueCAqICh0aGlzLndhbGxXaWR0aCArIHRoaXMubWF6ZVdpZHRoKTtcclxuXHQgXHRsZXQgeSA9IHRoaXMud2FsbFdpZHRoICsgY2VsbC55ICogKHRoaXMud2FsbFdpZHRoICsgdGhpcy5tYXplV2lkdGgpO1xyXG5cclxuXHQgXHRsZXQgeEJvcmRlciA9IHggKyB0aGlzLm1hemVXaWR0aDtcclxuXHQgXHRsZXQgeUJvcmRlciA9IHkgKyB0aGlzLm1hemVXaWR0aDtcclxuXHJcblx0IFx0Zm9yIChsZXQgaXggPSB4OyBpeCA8IHhCb3JkZXI7IGl4KyspIHtcclxuXHRcdFx0Zm9yIChsZXQgaXkgPSB5OyBpeSA8IHlCb3JkZXI7IGl5KyspIHtcclxuXHRcdFx0XHR0aGlzLmdyaWRbaXhdW2l5XSA9IHZhbHVlIHx8IDA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnZpcnR1YWxHcmlkW2NlbGwueF1bY2VsbC55XSA9IHZhbHVlIHx8IDA7XHJcblx0IH1cclxuXHQgRHJhd1dhbGxUbyhjZWxsLCBkaXIsIHZhbHVlKSB7XHJcblx0IFx0bGV0IGNlbGxYUG9zaXRpb24gPSB0aGlzLndhbGxXaWR0aCArIGNlbGwueCAqICh0aGlzLndhbGxXaWR0aCArIHRoaXMubWF6ZVdpZHRoKTtcclxuXHQgXHRsZXQgY2VsbFlQb3NpdGlvbiA9IHRoaXMud2FsbFdpZHRoICsgY2VsbC55ICogKHRoaXMud2FsbFdpZHRoICsgdGhpcy5tYXplV2lkdGgpO1xyXG5cclxuIFx0XHRsZXQgZ2FwU3RhcnRYID0gY2VsbFhQb3NpdGlvbiArIChkaXIueCA9PT0gMSA/IHRoaXMubWF6ZVdpZHRoIDogZGlyLnggPT09IC0xID8gLXRoaXMud2FsbFdpZHRoIDogMCk7XHJcbiBcdFx0bGV0IGdhcFN0YXJ0WSA9IGNlbGxZUG9zaXRpb24gKyAoZGlyLnkgPT09IDEgPyB0aGlzLm1hemVXaWR0aCA6IGRpci55ID09PSAtMSA/IC10aGlzLndhbGxXaWR0aCA6IDApO1xyXG5cclxuIFx0XHRmb3IgKGxldCB4ID0gZ2FwU3RhcnRYOyB4IDwgZ2FwU3RhcnRYICsgKE1hdGguYWJzKGRpci54KSAqIHRoaXMud2FsbFdpZHRoKSArIChNYXRoLmFicyhkaXIueSkgKiB0aGlzLm1hemVXaWR0aCk7IHgrKykge1xyXG4gXHRcdFx0Zm9yIChsZXQgeSA9IGdhcFN0YXJ0WTsgeSA8IGdhcFN0YXJ0WSArIChNYXRoLmFicyhkaXIueSkgKiB0aGlzLndhbGxXaWR0aCkgKyAoTWF0aC5hYnMoZGlyLngpICogdGhpcy5tYXplV2lkdGgpOyB5KyspIHtcclxuIFx0XHRcdFx0dGhpcy5ncmlkW3hdW3ldID0gdmFsdWUgfHwgMDtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcblx0IH1cclxuXHQgRHJhd0NlbGxUbyhjZWxsLCBkaXIsIHZhbHVlKSB7XHJcblx0IFx0dGhpcy5EcmF3V2FsbFRvKGNlbGwsIGRpciwgdmFsdWUpO1xyXG5cclxuXHQgXHR0aGlzLkRyYXdDZWxsKHtcclxuXHQgXHRcdHg6IGNlbGwueCArIGRpci54LFxyXG5cdCBcdFx0eTogY2VsbC55ICsgZGlyLnlcclxuXHQgXHR9LCB2YWx1ZSk7XHJcblx0IH1cclxuXHQgRHJhd0NlbGxGcm9tKGNlbGwsIGRpciwgdmFsdWUpIHtcclxuXHQgXHR0aGlzLkRyYXdXYWxsVG8oY2VsbCwgZGlyLCB2YWx1ZSk7XHJcblxyXG5cdCBcdHRoaXMuRHJhd0NlbGwoY2VsbCwgdmFsdWUpO1xyXG5cdCB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGV2ZWxHZW5lcmF0b3IuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 6:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {// A Javascript implementaion of the \"xorwow\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this, strseed = '';\n\n  // Set up generator function.\n  me.next = function() {\n    var t = (me.x ^ (me.x >>> 2));\n    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;\n    return (me.d = (me.d + 362437 | 0)) +\n       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;\n  };\n\n  me.x = 0;\n  me.y = 0;\n  me.z = 0;\n  me.w = 0;\n  me.v = 0;\n\n  if (seed === (seed | 0)) {\n    // Integer seed.\n    me.x = seed;\n  } else {\n    // String seed.\n    strseed += seed;\n  }\n\n  // Mix in string seed, then discard an initial batch of 64 values.\n  for (var k = 0; k < strseed.length + 64; k++) {\n    me.x ^= strseed.charCodeAt(k) | 0;\n    if (k == strseed.length) {\n      me.d = me.x << 10 ^ me.x >>> 4;\n    }\n    me.next();\n  }\n}\n\nfunction copy(f, t) {\n  t.x = f.x;\n  t.y = f.y;\n  t.z = f.z;\n  t.w = f.w;\n  t.v = f.v;\n  t.d = f.d;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(3) && __webpack_require__(4)) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.xorwow = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(3)   // present with an AMD loader\n);\n\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NlZWRyYW5kb20vbGliL3hvcndvdy5qcz8zOWZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJrQ0FBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsYUFBYTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUIsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRCxnREFBcUIsYUFBYSxFQUFFO0FBQ3BDLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yd293XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IChtZS54IF4gKG1lLnggPj4+IDIpKTtcbiAgICBtZS54ID0gbWUueTsgbWUueSA9IG1lLno7IG1lLnogPSBtZS53OyBtZS53ID0gbWUudjtcbiAgICByZXR1cm4gKG1lLmQgPSAobWUuZCArIDM2MjQzNyB8IDApKSArXG4gICAgICAgKG1lLnYgPSAobWUudiBeIChtZS52IDw8IDQpKSBeICh0IF4gKHQgPDwgMSkpKSB8IDA7XG4gIH07XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG4gIG1lLnYgPSAwO1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBpZiAoayA9PSBzdHJzZWVkLmxlbmd0aCkge1xuICAgICAgbWUuZCA9IG1lLnggPDwgMTAgXiBtZS54ID4+PiA0O1xuICAgIH1cbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgdC52ID0gZi52O1xuICB0LmQgPSBmLmQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcndvdyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NlZWRyYW5kb20vbGliL3hvcndvdy5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 7:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {// A Javascript implementaion of the \"xorshift7\" algorithm by\n// François Panneton and Pierre L'ecuyer:\n// \"On the Xorgshift Random Number Generators\"\n// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this;\n\n  // Set up generator function.\n  me.next = function() {\n    // Update xor generator.\n    var X = me.x, i = me.i, t, v, w;\n    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);\n    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);\n    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);\n    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);\n    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);\n    X[i] = v;\n    me.i = (i + 1) & 7;\n    return v;\n  };\n\n  function init(me, seed) {\n    var j, w, X = [];\n\n    if (seed === (seed | 0)) {\n      // Seed state array using a 32-bit integer.\n      w = X[0] = seed;\n    } else {\n      // Seed state using a string.\n      seed = '' + seed;\n      for (j = 0; j < seed.length; ++j) {\n        X[j & 7] = (X[j & 7] << 15) ^\n            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);\n      }\n    }\n    // Enforce an array length of 8, not all zeroes.\n    while (X.length < 8) X.push(0);\n    for (j = 0; j < 8 && X[j] === 0; ++j);\n    if (j == 8) w = X[7] = -1; else w = X[j];\n\n    me.x = X;\n    me.i = 0;\n\n    // Discard an initial 256 values.\n    for (j = 256; j > 0; --j) {\n      me.next();\n    }\n  }\n\n  init(me, seed);\n}\n\nfunction copy(f, t) {\n  t.x = f.x.slice();\n  t.i = f.i;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  if (seed == null) seed = +(new Date);\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (state.x) copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(3) && __webpack_require__(4)) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.xorshift7 = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(3)   // present with an AMD loader\n);\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NlZWRyYW5kb20vbGliL3hvcnNoaWZ0Ny5qcz9iZTVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJrQ0FBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUIsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRCxnREFBcUIsYUFBYSxFQUFFO0FBQ3BDLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yc2hpZnQ3XCIgYWxnb3JpdGhtIGJ5XG4vLyBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllcjpcbi8vIFwiT24gdGhlIFhvcmdzaGlmdCBSYW5kb20gTnVtYmVyIEdlbmVyYXRvcnNcIlxuLy8gaHR0cDovL3NhbHVjLmVuZ3IudWNvbm4uZWR1L3JlZnMvY3J5cHRvL3JuZy9wYW5uZXRvbjA1b250aGV4b3JzaGlmdC5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVXBkYXRlIHhvciBnZW5lcmF0b3IuXG4gICAgdmFyIFggPSBtZS54LCBpID0gbWUuaSwgdCwgdiwgdztcbiAgICB0ID0gWFtpXTsgdCBePSAodCA+Pj4gNyk7IHYgPSB0IF4gKHQgPDwgMjQpO1xuICAgIHQgPSBYWyhpICsgMSkgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDEwKTtcbiAgICB0ID0gWFsoaSArIDMpICYgN107IHYgXj0gdCBeICh0ID4+PiAzKTtcbiAgICB0ID0gWFsoaSArIDQpICYgN107IHYgXj0gdCBeICh0IDw8IDcpO1xuICAgIHQgPSBYWyhpICsgNykgJiA3XTsgdCA9IHQgXiAodCA8PCAxMyk7IHYgXj0gdCBeICh0IDw8IDkpO1xuICAgIFhbaV0gPSB2O1xuICAgIG1lLmkgPSAoaSArIDEpICYgNztcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIGosIHcsIFggPSBbXTtcblxuICAgIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIGFycmF5IHVzaW5nIGEgMzItYml0IGludGVnZXIuXG4gICAgICB3ID0gWFswXSA9IHNlZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgdXNpbmcgYSBzdHJpbmcuXG4gICAgICBzZWVkID0gJycgKyBzZWVkO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHNlZWQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgWFtqICYgN10gPSAoWFtqICYgN10gPDwgMTUpIF5cbiAgICAgICAgICAgIChzZWVkLmNoYXJDb2RlQXQoaikgKyBYWyhqICsgMSkgJiA3XSA8PCAxMyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVuZm9yY2UgYW4gYXJyYXkgbGVuZ3RoIG9mIDgsIG5vdCBhbGwgemVyb2VzLlxuICAgIHdoaWxlIChYLmxlbmd0aCA8IDgpIFgucHVzaCgwKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgOCAmJiBYW2pdID09PSAwOyArK2opO1xuICAgIGlmIChqID09IDgpIHcgPSBYWzddID0gLTE7IGVsc2UgdyA9IFhbal07XG5cbiAgICBtZS54ID0gWDtcbiAgICBtZS5pID0gMDtcblxuICAgIC8vIERpc2NhcmQgYW4gaW5pdGlhbCAyNTYgdmFsdWVzLlxuICAgIGZvciAoaiA9IDI1NjsgaiA+IDA7IC0taikge1xuICAgICAgbWUubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54LnNsaWNlKCk7XG4gIHQuaSA9IGYuaTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLngpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3JzaGlmdDcgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 8:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\n//\n// This fast non-cryptographic random number generator is designed for\n// use in Monte-Carlo algorithms. It combines a long-period xorshift\n// generator with a Weyl generator, and it passes all common batteries\n// of stasticial tests for randomness while consuming only a few nanoseconds\n// for each prng generated.  For background on the generator, see Brent's\n// paper: \"Some long-period random number generators using shifts and xors.\"\n// http://arxiv.org/pdf/1004.3115v1.pdf\n//\n// Usage:\n//\n// var xor4096 = require('xor4096');\n// random = xor4096(1);                        // Seed with int32 or string.\n// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.\n// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.\n//\n// For nonzero numeric keys, this impelementation provides a sequence\n// identical to that by Brent's xorgens 3 implementaion in C.  This\n// implementation also provides for initalizing the generator with\n// string seeds, or for saving and restoring the state of the generator.\n//\n// On Chrome, this prng benchmarks about 2.1 times slower than\n// Javascript's built-in Math.random().\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this;\n\n  // Set up generator function.\n  me.next = function() {\n    var w = me.w,\n        X = me.X, i = me.i, t, v;\n    // Update Weyl generator.\n    me.w = w = (w + 0x61c88647) | 0;\n    // Update xor generator.\n    v = X[(i + 34) & 127];\n    t = X[i = ((i + 1) & 127)];\n    v ^= v << 13;\n    t ^= t << 17;\n    v ^= v >>> 15;\n    t ^= t >>> 12;\n    // Update Xor generator array state.\n    v = X[i] = v ^ t;\n    me.i = i;\n    // Result is the combination.\n    return (v + (w ^ (w >>> 16))) | 0;\n  };\n\n  function init(me, seed) {\n    var t, v, i, j, w, X = [], limit = 128;\n    if (seed === (seed | 0)) {\n      // Numeric seeds initialize v, which is used to generates X.\n      v = seed;\n      seed = null;\n    } else {\n      // String seeds are mixed into v and X one character at a time.\n      seed = seed + '\\0';\n      v = 0;\n      limit = Math.max(limit, seed.length);\n    }\n    // Initialize circular array and weyl value.\n    for (i = 0, j = -32; j < limit; ++j) {\n      // Put the unicode characters into the array, and shuffle them.\n      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);\n      // After 32 shuffles, take v as the starting w value.\n      if (j === 0) w = v;\n      v ^= v << 10;\n      v ^= v >>> 15;\n      v ^= v << 4;\n      v ^= v >>> 13;\n      if (j >= 0) {\n        w = (w + 0x61c88647) | 0;     // Weyl.\n        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.\n        i = (0 == t) ? i + 1 : 0;     // Count zeroes.\n      }\n    }\n    // We have detected all zeroes; make the key nonzero.\n    if (i >= 128) {\n      X[(seed && seed.length || 0) & 127] = -1;\n    }\n    // Run the generator 512 times to further mix the state before using it.\n    // Factoring this as a function slows the main generator, so it is just\n    // unrolled here.  The weyl generator is not advanced while warming up.\n    i = 127;\n    for (j = 4 * 128; j > 0; --j) {\n      v = X[(i + 34) & 127];\n      t = X[i = ((i + 1) & 127)];\n      v ^= v << 13;\n      t ^= t << 17;\n      v ^= v >>> 15;\n      t ^= t >>> 12;\n      X[i] = v ^ t;\n    }\n    // Storing state as object members is faster than using closure variables.\n    me.w = w;\n    me.X = X;\n    me.i = i;\n  }\n\n  init(me, seed);\n}\n\nfunction copy(f, t) {\n  t.i = f.i;\n  t.w = f.w;\n  t.X = f.X.slice();\n  return t;\n};\n\nfunction impl(seed, opts) {\n  if (seed == null) seed = +(new Date);\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (state.X) copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(3) && __webpack_require__(4)) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.xor4096 = impl;\n}\n\n})(\n  this,                                     // window object or global\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(3)   // present with an AMD loader\n);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NlZWRyYW5kb20vbGliL3hvcjQwOTYuanM/ZjgyMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoia0NBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsOENBQThDO0FBQzlDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxvQ0FBb0M7QUFDcEMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CLEVBQUU7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0RBQXFCLGFBQWEsRUFBRTtBQUNwQyxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIFJpY2hhcmQgQnJlbnQncyBYb3JnZW5zIHhvcjQwOTYgYWxnb3JpdGhtLlxuLy9cbi8vIFRoaXMgZmFzdCBub24tY3J5cHRvZ3JhcGhpYyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyBkZXNpZ25lZCBmb3Jcbi8vIHVzZSBpbiBNb250ZS1DYXJsbyBhbGdvcml0aG1zLiBJdCBjb21iaW5lcyBhIGxvbmctcGVyaW9kIHhvcnNoaWZ0XG4vLyBnZW5lcmF0b3Igd2l0aCBhIFdleWwgZ2VuZXJhdG9yLCBhbmQgaXQgcGFzc2VzIGFsbCBjb21tb24gYmF0dGVyaWVzXG4vLyBvZiBzdGFzdGljaWFsIHRlc3RzIGZvciByYW5kb21uZXNzIHdoaWxlIGNvbnN1bWluZyBvbmx5IGEgZmV3IG5hbm9zZWNvbmRzXG4vLyBmb3IgZWFjaCBwcm5nIGdlbmVyYXRlZC4gIEZvciBiYWNrZ3JvdW5kIG9uIHRoZSBnZW5lcmF0b3IsIHNlZSBCcmVudCdzXG4vLyBwYXBlcjogXCJTb21lIGxvbmctcGVyaW9kIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9ycyB1c2luZyBzaGlmdHMgYW5kIHhvcnMuXCJcbi8vIGh0dHA6Ly9hcnhpdi5vcmcvcGRmLzEwMDQuMzExNXYxLnBkZlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciB4b3I0MDk2ID0gcmVxdWlyZSgneG9yNDA5NicpO1xuLy8gcmFuZG9tID0geG9yNDA5NigxKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkIHdpdGggaW50MzIgb3Igc3RyaW5nLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbSgpLCAwLjE1MjA0MzY0NTA1Mzg1NDcpOyAvLyAoMCwgMSkgcmFuZ2UsIDUzIGJpdHMuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tLmludDMyKCksIDE4MDY1MzQ4OTcpOyAgIC8vIHNpZ25lZCBpbnQzMiwgMzIgYml0cy5cbi8vXG4vLyBGb3Igbm9uemVybyBudW1lcmljIGtleXMsIHRoaXMgaW1wZWxlbWVudGF0aW9uIHByb3ZpZGVzIGEgc2VxdWVuY2Vcbi8vIGlkZW50aWNhbCB0byB0aGF0IGJ5IEJyZW50J3MgeG9yZ2VucyAzIGltcGxlbWVudGFpb24gaW4gQy4gIFRoaXNcbi8vIGltcGxlbWVudGF0aW9uIGFsc28gcHJvdmlkZXMgZm9yIGluaXRhbGl6aW5nIHRoZSBnZW5lcmF0b3Igd2l0aFxuLy8gc3RyaW5nIHNlZWRzLCBvciBmb3Igc2F2aW5nIGFuZCByZXN0b3JpbmcgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXG4vL1xuLy8gT24gQ2hyb21lLCB0aGlzIHBybmcgYmVuY2htYXJrcyBhYm91dCAyLjEgdGltZXMgc2xvd2VyIHRoYW5cbi8vIEphdmFzY3JpcHQncyBidWlsdC1pbiBNYXRoLnJhbmRvbSgpLlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IG1lLncsXG4gICAgICAgIFggPSBtZS5YLCBpID0gbWUuaSwgdCwgdjtcbiAgICAvLyBVcGRhdGUgV2V5bCBnZW5lcmF0b3IuXG4gICAgbWUudyA9IHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgdiBePSB2IDw8IDEzO1xuICAgIHQgXj0gdCA8PCAxNztcbiAgICB2IF49IHYgPj4+IDE1O1xuICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgLy8gVXBkYXRlIFhvciBnZW5lcmF0b3IgYXJyYXkgc3RhdGUuXG4gICAgdiA9IFhbaV0gPSB2IF4gdDtcbiAgICBtZS5pID0gaTtcbiAgICAvLyBSZXN1bHQgaXMgdGhlIGNvbWJpbmF0aW9uLlxuICAgIHJldHVybiAodiArICh3IF4gKHcgPj4+IDE2KSkpIHwgMDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIHQsIHYsIGksIGosIHcsIFggPSBbXSwgbGltaXQgPSAxMjg7XG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIE51bWVyaWMgc2VlZHMgaW5pdGlhbGl6ZSB2LCB3aGljaCBpcyB1c2VkIHRvIGdlbmVyYXRlcyBYLlxuICAgICAgdiA9IHNlZWQ7XG4gICAgICBzZWVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyaW5nIHNlZWRzIGFyZSBtaXhlZCBpbnRvIHYgYW5kIFggb25lIGNoYXJhY3RlciBhdCBhIHRpbWUuXG4gICAgICBzZWVkID0gc2VlZCArICdcXDAnO1xuICAgICAgdiA9IDA7XG4gICAgICBsaW1pdCA9IE1hdGgubWF4KGxpbWl0LCBzZWVkLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgY2lyY3VsYXIgYXJyYXkgYW5kIHdleWwgdmFsdWUuXG4gICAgZm9yIChpID0gMCwgaiA9IC0zMjsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgIC8vIFB1dCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlIGFycmF5LCBhbmQgc2h1ZmZsZSB0aGVtLlxuICAgICAgaWYgKHNlZWQpIHYgXj0gc2VlZC5jaGFyQ29kZUF0KChqICsgMzIpICUgc2VlZC5sZW5ndGgpO1xuICAgICAgLy8gQWZ0ZXIgMzIgc2h1ZmZsZXMsIHRha2UgdiBhcyB0aGUgc3RhcnRpbmcgdyB2YWx1ZS5cbiAgICAgIGlmIChqID09PSAwKSB3ID0gdjtcbiAgICAgIHYgXj0gdiA8PCAxMDtcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB2IF49IHYgPDwgNDtcbiAgICAgIHYgXj0gdiA+Pj4gMTM7XG4gICAgICBpZiAoaiA+PSAwKSB7XG4gICAgICAgIHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDsgICAgIC8vIFdleWwuXG4gICAgICAgIHQgPSAoWFtqICYgMTI3XSBePSAodiArIHcpKTsgIC8vIENvbWJpbmUgeG9yIGFuZCB3ZXlsIHRvIGluaXQgYXJyYXkuXG4gICAgICAgIGkgPSAoMCA9PSB0KSA/IGkgKyAxIDogMDsgICAgIC8vIENvdW50IHplcm9lcy5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhbGwgemVyb2VzOyBtYWtlIHRoZSBrZXkgbm9uemVyby5cbiAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgIFhbKHNlZWQgJiYgc2VlZC5sZW5ndGggfHwgMCkgJiAxMjddID0gLTE7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIDUxMiB0aW1lcyB0byBmdXJ0aGVyIG1peCB0aGUgc3RhdGUgYmVmb3JlIHVzaW5nIGl0LlxuICAgIC8vIEZhY3RvcmluZyB0aGlzIGFzIGEgZnVuY3Rpb24gc2xvd3MgdGhlIG1haW4gZ2VuZXJhdG9yLCBzbyBpdCBpcyBqdXN0XG4gICAgLy8gdW5yb2xsZWQgaGVyZS4gIFRoZSB3ZXlsIGdlbmVyYXRvciBpcyBub3QgYWR2YW5jZWQgd2hpbGUgd2FybWluZyB1cC5cbiAgICBpID0gMTI3O1xuICAgIGZvciAoaiA9IDQgKiAxMjg7IGogPiAwOyAtLWopIHtcbiAgICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgICAgdiBePSB2IDw8IDEzO1xuICAgICAgdCBePSB0IDw8IDE3O1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgICBYW2ldID0gdiBeIHQ7XG4gICAgfVxuICAgIC8vIFN0b3Jpbmcgc3RhdGUgYXMgb2JqZWN0IG1lbWJlcnMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMuXG4gICAgbWUudyA9IHc7XG4gICAgbWUuWCA9IFg7XG4gICAgbWUuaSA9IGk7XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC53ID0gZi53O1xuICB0LlggPSBmLlguc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5YKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yNDA5NiA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cgb2JqZWN0IG9yIGdsb2JhbFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 9:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {// A Javascript implementaion of the \"Tyche-i\" prng algorithm by\n// Samuel Neves and Filipe Araujo.\n// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this, strseed = '';\n\n  // Set up generator function.\n  me.next = function() {\n    var b = me.b, c = me.c, d = me.d, a = me.a;\n    b = (b << 25) ^ (b >>> 7) ^ c;\n    c = (c - d) | 0;\n    d = (d << 24) ^ (d >>> 8) ^ a;\n    a = (a - b) | 0;\n    me.b = b = (b << 20) ^ (b >>> 12) ^ c;\n    me.c = c = (c - d) | 0;\n    me.d = (d << 16) ^ (c >>> 16) ^ a;\n    return me.a = (a - b) | 0;\n  };\n\n  /* The following is non-inverted tyche, which has better internal\n   * bit diffusion, but which is about 25% slower than tyche-i in JS.\n  me.next = function() {\n    var a = me.a, b = me.b, c = me.c, d = me.d;\n    a = (me.a + me.b | 0) >>> 0;\n    d = me.d ^ a; d = d << 16 ^ d >>> 16;\n    c = me.c + d | 0;\n    b = me.b ^ c; b = b << 12 ^ d >>> 20;\n    me.a = a = a + b | 0;\n    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;\n    me.c = c = c + d | 0;\n    b = b ^ c;\n    return me.b = (b << 7 ^ b >>> 25);\n  }\n  */\n\n  me.a = 0;\n  me.b = 0;\n  me.c = 2654435769 | 0;\n  me.d = 1367130551;\n\n  if (seed === Math.floor(seed)) {\n    // Integer seed.\n    me.a = (seed / 0x100000000) | 0;\n    me.b = seed | 0;\n  } else {\n    // String seed.\n    strseed += seed;\n  }\n\n  // Mix in string seed, then discard an initial batch of 64 values.\n  for (var k = 0; k < strseed.length + 20; k++) {\n    me.b ^= strseed.charCodeAt(k) | 0;\n    me.next();\n  }\n}\n\nfunction copy(f, t) {\n  t.a = f.a;\n  t.b = f.b;\n  t.c = f.c;\n  t.d = f.d;\n  return t;\n};\n\nfunction impl(seed, opts) {\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(3) && __webpack_require__(4)) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.tychei = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(3)   // present with an AMD loader\n);\n\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcz8yOWM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJrQ0FBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUIsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRCxnREFBcUIsYUFBYSxFQUFFO0FBQ3BDLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwiVHljaGUtaVwiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8uXG4vLyBTZWUgaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZCwgYSA9IG1lLmE7XG4gICAgYiA9IChiIDw8IDI1KSBeIChiID4+PiA3KSBeIGM7XG4gICAgYyA9IChjIC0gZCkgfCAwO1xuICAgIGQgPSAoZCA8PCAyNCkgXiAoZCA+Pj4gOCkgXiBhO1xuICAgIGEgPSAoYSAtIGIpIHwgMDtcbiAgICBtZS5iID0gYiA9IChiIDw8IDIwKSBeIChiID4+PiAxMikgXiBjO1xuICAgIG1lLmMgPSBjID0gKGMgLSBkKSB8IDA7XG4gICAgbWUuZCA9IChkIDw8IDE2KSBeIChjID4+PiAxNikgXiBhO1xuICAgIHJldHVybiBtZS5hID0gKGEgLSBiKSB8IDA7XG4gIH07XG5cbiAgLyogVGhlIGZvbGxvd2luZyBpcyBub24taW52ZXJ0ZWQgdHljaGUsIHdoaWNoIGhhcyBiZXR0ZXIgaW50ZXJuYWxcbiAgICogYml0IGRpZmZ1c2lvbiwgYnV0IHdoaWNoIGlzIGFib3V0IDI1JSBzbG93ZXIgdGhhbiB0eWNoZS1pIGluIEpTLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSBtZS5hLCBiID0gbWUuYiwgYyA9IG1lLmMsIGQgPSBtZS5kO1xuICAgIGEgPSAobWUuYSArIG1lLmIgfCAwKSA+Pj4gMDtcbiAgICBkID0gbWUuZCBeIGE7IGQgPSBkIDw8IDE2IF4gZCA+Pj4gMTY7XG4gICAgYyA9IG1lLmMgKyBkIHwgMDtcbiAgICBiID0gbWUuYiBeIGM7IGIgPSBiIDw8IDEyIF4gZCA+Pj4gMjA7XG4gICAgbWUuYSA9IGEgPSBhICsgYiB8IDA7XG4gICAgZCA9IGQgXiBhOyBtZS5kID0gZCA9IGQgPDwgOCBeIGQgPj4+IDI0O1xuICAgIG1lLmMgPSBjID0gYyArIGQgfCAwO1xuICAgIGIgPSBiIF4gYztcbiAgICByZXR1cm4gbWUuYiA9IChiIDw8IDcgXiBiID4+PiAyNSk7XG4gIH1cbiAgKi9cblxuICBtZS5hID0gMDtcbiAgbWUuYiA9IDA7XG4gIG1lLmMgPSAyNjU0NDM1NzY5IHwgMDtcbiAgbWUuZCA9IDEzNjcxMzA1NTE7XG5cbiAgaWYgKHNlZWQgPT09IE1hdGguZmxvb3Ioc2VlZCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUuYSA9IChzZWVkIC8gMHgxMDAwMDAwMDApIHwgMDtcbiAgICBtZS5iID0gc2VlZCB8IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyAyMDsgaysrKSB7XG4gICAgbWUuYiBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5hID0gZi5hO1xuICB0LmIgPSBmLmI7XG4gIHQuYyA9IGYuYztcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMudHljaGVpID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2VlZHJhbmRvbS9saWIvdHljaGVpLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 10:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\nCopyright 2014 David Bau.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n(function (pool, math) {\n//\n// The following constants are related to IEEE 754 limits.\n//\nvar global = this,\n    width = 256,        // each RC4 output is 0 <= x < 256\n    chunks = 6,         // at least six RC4 outputs for each double\n    digits = 52,        // there are 52 significant digits in a double\n    rngname = 'random', // rngname: name for Math.random and Math.seedrandom\n    startdenom = math.pow(width, chunks),\n    significance = math.pow(2, digits),\n    overflow = significance * 2,\n    mask = width - 1,\n    nodecrypto;         // node.js crypto module, initialized at the bottom.\n\n//\n// seedrandom()\n// This is the seedrandom function described above.\n//\nfunction seedrandom(seed, options, callback) {\n  var key = [];\n  options = (options == true) ? { entropy: true } : (options || {});\n\n  // Flatten the seed string or build one from local entropy if needed.\n  var shortseed = mixkey(flatten(\n    options.entropy ? [seed, tostring(pool)] :\n    (seed == null) ? autoseed() : seed, 3), key);\n\n  // Use the seed to initialize an ARC4 generator.\n  var arc4 = new ARC4(key);\n\n  // This function returns a random double in [0, 1) that contains\n  // randomness in every bit of the mantissa of the IEEE 754 value.\n  var prng = function() {\n    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48\n        d = startdenom,                 //   and denominator d = 2 ^ 48.\n        x = 0;                          //   and no 'extra last byte'.\n    while (n < significance) {          // Fill up all significant digits by\n      n = (n + x) * width;              //   shifting numerator and\n      d *= width;                       //   denominator and generating a\n      x = arc4.g(1);                    //   new least-significant-byte.\n    }\n    while (n >= overflow) {             // To avoid rounding up, before adding\n      n /= 2;                           //   last byte, shift everything\n      d /= 2;                           //   right using integer math until\n      x >>>= 1;                         //   we have exactly the desired bits.\n    }\n    return (n + x) / d;                 // Form the number within [0, 1).\n  };\n\n  prng.int32 = function() { return arc4.g(4) | 0; }\n  prng.quick = function() { return arc4.g(4) / 0x100000000; }\n  prng.double = prng;\n\n  // Mix the randomness into accumulated entropy.\n  mixkey(tostring(arc4.S), pool);\n\n  // Calling convention: what to return as a function of prng, seed, is_math.\n  return (options.pass || callback ||\n      function(prng, seed, is_math_call, state) {\n        if (state) {\n          // Load the arc4 state from the given state if it has an S array.\n          if (state.S) { copy(state, arc4); }\n          // Only provide the .state method if requested via options.state.\n          prng.state = function() { return copy(arc4, {}); }\n        }\n\n        // If called as a method of Math (Math.seedrandom()), mutate\n        // Math.random because that is how seedrandom.js has worked since v1.0.\n        if (is_math_call) { math[rngname] = prng; return seed; }\n\n        // Otherwise, it is a newer calling convention, so return the\n        // prng directly.\n        else return prng;\n      })(\n  prng,\n  shortseed,\n  'global' in options ? options.global : (this == math),\n  options.state);\n}\nmath['seed' + rngname] = seedrandom;\n\n//\n// ARC4\n//\n// An ARC4 implementation.  The constructor takes a key in the form of\n// an array of at most (width) integers that should be 0 <= x < (width).\n//\n// The g(count) method returns a pseudorandom integer that concatenates\n// the next (count) outputs from ARC4.  Its return value is a number x\n// that is in the range 0 <= x < (width ^ count).\n//\nfunction ARC4(key) {\n  var t, keylen = key.length,\n      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];\n\n  // The empty key [] is treated as [0].\n  if (!keylen) { key = [keylen++]; }\n\n  // Set up S using the standard key scheduling algorithm.\n  while (i < width) {\n    s[i] = i++;\n  }\n  for (i = 0; i < width; i++) {\n    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];\n    s[j] = t;\n  }\n\n  // The \"g\" method returns the next (count) outputs as one number.\n  (me.g = function(count) {\n    // Using instance members instead of closure state nearly doubles speed.\n    var t, r = 0,\n        i = me.i, j = me.j, s = me.S;\n    while (count--) {\n      t = s[i = mask & (i + 1)];\n      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];\n    }\n    me.i = i; me.j = j;\n    return r;\n    // For robust unpredictability, the function call below automatically\n    // discards an initial batch of values.  This is called RC4-drop[256].\n    // See http://google.com/search?q=rsa+fluhrer+response&btnI\n  })(width);\n}\n\n//\n// copy()\n// Copies internal state of ARC4 to or from a plain object.\n//\nfunction copy(f, t) {\n  t.i = f.i;\n  t.j = f.j;\n  t.S = f.S.slice();\n  return t;\n};\n\n//\n// flatten()\n// Converts an object tree to nested arrays of strings.\n//\nfunction flatten(obj, depth) {\n  var result = [], typ = (typeof obj), prop;\n  if (depth && typ == 'object') {\n    for (prop in obj) {\n      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}\n    }\n  }\n  return (result.length ? result : typ == 'string' ? obj : obj + '\\0');\n}\n\n//\n// mixkey()\n// Mixes a string seed into a key that is an array of integers, and\n// returns a shortened string seed that is equivalent to the result key.\n//\nfunction mixkey(seed, key) {\n  var stringseed = seed + '', smear, j = 0;\n  while (j < stringseed.length) {\n    key[mask & j] =\n      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));\n  }\n  return tostring(key);\n}\n\n//\n// autoseed()\n// Returns an object for autoseeding, using window.crypto and Node crypto\n// module if available.\n//\nfunction autoseed() {\n  try {\n    var out;\n    if (nodecrypto && (out = nodecrypto.randomBytes)) {\n      // The use of 'out' to remember randomBytes makes tight minified code.\n      out = out(width);\n    } else {\n      out = new Uint8Array(width);\n      (global.crypto || global.msCrypto).getRandomValues(out);\n    }\n    return tostring(out);\n  } catch (e) {\n    var browser = global.navigator,\n        plugins = browser && browser.plugins;\n    return [+new Date, global, plugins, global.screen, tostring(pool)];\n  }\n}\n\n//\n// tostring()\n// Converts an array of charcodes to a string\n//\nfunction tostring(a) {\n  return String.fromCharCode.apply(0, a);\n}\n\n//\n// When seedrandom.js is loaded, we immediately mix a few bits\n// from the built-in RNG into the entropy pool.  Because we do\n// not want to interfere with deterministic PRNG state later,\n// seedrandom will not call math.random on its own again after\n// initialization.\n//\nmixkey(math.random(), pool);\n\n//\n// Nodejs and AMD support: export the implementation as a module using\n// either convention.\n//\nif ((typeof module) == 'object' && module.exports) {\n  module.exports = seedrandom;\n  // When in node.js, try using crypto package for autoseeding.\n  try {\n    nodecrypto = __webpack_require__(11);\n  } catch (ex) {}\n} else if (true) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return seedrandom; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n// End anonymous scope, and pass initial values.\n})(\n  [],     // pool: entropy pool starts empty\n  Math    // math: package containing random, pow, and seedrandom\n);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NlZWRyYW5kb20vc2VlZHJhbmRvbS5qcz85ZmM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQixpQkFBaUI7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEI7QUFDQSwyQkFBMkI7QUFDM0IsYUFBYTtBQUNiLGFBQWE7QUFDYixlQUFlO0FBQ2Y7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUEsMkJBQTJCLHNCQUFzQjtBQUNqRCwyQkFBMkIsZ0NBQWdDO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQSxtQ0FBbUMscUJBQXFCLEVBQUU7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0IsYUFBYTs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixrQkFBa0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDLEVBQUU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxnREFBcUIsbUJBQW1CLEVBQUU7QUFDMUM7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE0IERhdmlkIEJhdS5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5JTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcblRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5TT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cblxuKGZ1bmN0aW9uIChwb29sLCBtYXRoKSB7XG4vL1xuLy8gVGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIHJlbGF0ZWQgdG8gSUVFRSA3NTQgbGltaXRzLlxuLy9cbnZhciBnbG9iYWwgPSB0aGlzLFxuICAgIHdpZHRoID0gMjU2LCAgICAgICAgLy8gZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICAgIGNodW5rcyA9IDYsICAgICAgICAgLy8gYXQgbGVhc3Qgc2l4IFJDNCBvdXRwdXRzIGZvciBlYWNoIGRvdWJsZVxuICAgIGRpZ2l0cyA9IDUyLCAgICAgICAgLy8gdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxuICAgIHJuZ25hbWUgPSAncmFuZG9tJywgLy8gcm5nbmFtZTogbmFtZSBmb3IgTWF0aC5yYW5kb20gYW5kIE1hdGguc2VlZHJhbmRvbVxuICAgIHN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcbiAgICBzaWduaWZpY2FuY2UgPSBtYXRoLnBvdygyLCBkaWdpdHMpLFxuICAgIG92ZXJmbG93ID0gc2lnbmlmaWNhbmNlICogMixcbiAgICBtYXNrID0gd2lkdGggLSAxLFxuICAgIG5vZGVjcnlwdG87ICAgICAgICAgLy8gbm9kZS5qcyBjcnlwdG8gbW9kdWxlLCBpbml0aWFsaXplZCBhdCB0aGUgYm90dG9tLlxuXG4vL1xuLy8gc2VlZHJhbmRvbSgpXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbi8vXG5mdW5jdGlvbiBzZWVkcmFuZG9tKHNlZWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBrZXkgPSBbXTtcbiAgb3B0aW9ucyA9IChvcHRpb25zID09IHRydWUpID8geyBlbnRyb3B5OiB0cnVlIH0gOiAob3B0aW9ucyB8fCB7fSk7XG5cbiAgLy8gRmxhdHRlbiB0aGUgc2VlZCBzdHJpbmcgb3IgYnVpbGQgb25lIGZyb20gbG9jYWwgZW50cm9weSBpZiBuZWVkZWQuXG4gIHZhciBzaG9ydHNlZWQgPSBtaXhrZXkoZmxhdHRlbihcbiAgICBvcHRpb25zLmVudHJvcHkgPyBbc2VlZCwgdG9zdHJpbmcocG9vbCldIDpcbiAgICAoc2VlZCA9PSBudWxsKSA/IGF1dG9zZWVkKCkgOiBzZWVkLCAzKSwga2V5KTtcblxuICAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cbiAgdmFyIGFyYzQgPSBuZXcgQVJDNChrZXkpO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcbiAgLy8gcmFuZG9tbmVzcyBpbiBldmVyeSBiaXQgb2YgdGhlIG1hbnRpc3NhIG9mIHRoZSBJRUVFIDc1NCB2YWx1ZS5cbiAgdmFyIHBybmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGFyYzQuZyhjaHVua3MpLCAgICAgICAgICAgICAvLyBTdGFydCB3aXRoIGEgbnVtZXJhdG9yIG4gPCAyIF4gNDhcbiAgICAgICAgZCA9IHN0YXJ0ZGVub20sICAgICAgICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxuICAgICAgICB4ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYW5kIG5vICdleHRyYSBsYXN0IGJ5dGUnLlxuICAgIHdoaWxlIChuIDwgc2lnbmlmaWNhbmNlKSB7ICAgICAgICAgIC8vIEZpbGwgdXAgYWxsIHNpZ25pZmljYW50IGRpZ2l0cyBieVxuICAgICAgbiA9IChuICsgeCkgKiB3aWR0aDsgICAgICAgICAgICAgIC8vICAgc2hpZnRpbmcgbnVtZXJhdG9yIGFuZFxuICAgICAgZCAqPSB3aWR0aDsgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuICAgICAgeCA9IGFyYzQuZygxKTsgICAgICAgICAgICAgICAgICAgIC8vICAgbmV3IGxlYXN0LXNpZ25pZmljYW50LWJ5dGUuXG4gICAgfVxuICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7ICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHJvdW5kaW5nIHVwLCBiZWZvcmUgYWRkaW5nXG4gICAgICBuIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsYXN0IGJ5dGUsIHNoaWZ0IGV2ZXJ5dGhpbmdcbiAgICAgIGQgLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJpZ2h0IHVzaW5nIGludGVnZXIgbWF0aCB1bnRpbFxuICAgICAgeCA+Pj49IDE7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgd2UgaGF2ZSBleGFjdGx5IHRoZSBkZXNpcmVkIGJpdHMuXG4gICAgfVxuICAgIHJldHVybiAobiArIHgpIC8gZDsgICAgICAgICAgICAgICAgIC8vIEZvcm0gdGhlIG51bWJlciB3aXRoaW4gWzAsIDEpLlxuICB9O1xuXG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSB8IDA7IH1cbiAgcHJuZy5xdWljayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIC8gMHgxMDAwMDAwMDA7IH1cbiAgcHJuZy5kb3VibGUgPSBwcm5nO1xuXG4gIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXG4gIG1peGtleSh0b3N0cmluZyhhcmM0LlMpLCBwb29sKTtcblxuICAvLyBDYWxsaW5nIGNvbnZlbnRpb246IHdoYXQgdG8gcmV0dXJuIGFzIGEgZnVuY3Rpb24gb2YgcHJuZywgc2VlZCwgaXNfbWF0aC5cbiAgcmV0dXJuIChvcHRpb25zLnBhc3MgfHwgY2FsbGJhY2sgfHxcbiAgICAgIGZ1bmN0aW9uKHBybmcsIHNlZWQsIGlzX21hdGhfY2FsbCwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgLy8gTG9hZCB0aGUgYXJjNCBzdGF0ZSBmcm9tIHRoZSBnaXZlbiBzdGF0ZSBpZiBpdCBoYXMgYW4gUyBhcnJheS5cbiAgICAgICAgICBpZiAoc3RhdGUuUykgeyBjb3B5KHN0YXRlLCBhcmM0KTsgfVxuICAgICAgICAgIC8vIE9ubHkgcHJvdmlkZSB0aGUgLnN0YXRlIG1ldGhvZCBpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMuc3RhdGUuXG4gICAgICAgICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weShhcmM0LCB7fSk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGNhbGxlZCBhcyBhIG1ldGhvZCBvZiBNYXRoIChNYXRoLnNlZWRyYW5kb20oKSksIG11dGF0ZVxuICAgICAgICAvLyBNYXRoLnJhbmRvbSBiZWNhdXNlIHRoYXQgaXMgaG93IHNlZWRyYW5kb20uanMgaGFzIHdvcmtlZCBzaW5jZSB2MS4wLlxuICAgICAgICBpZiAoaXNfbWF0aF9jYWxsKSB7IG1hdGhbcm5nbmFtZV0gPSBwcm5nOyByZXR1cm4gc2VlZDsgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgaXQgaXMgYSBuZXdlciBjYWxsaW5nIGNvbnZlbnRpb24sIHNvIHJldHVybiB0aGVcbiAgICAgICAgLy8gcHJuZyBkaXJlY3RseS5cbiAgICAgICAgZWxzZSByZXR1cm4gcHJuZztcbiAgICAgIH0pKFxuICBwcm5nLFxuICBzaG9ydHNlZWQsXG4gICdnbG9iYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLmdsb2JhbCA6ICh0aGlzID09IG1hdGgpLFxuICBvcHRpb25zLnN0YXRlKTtcbn1cbm1hdGhbJ3NlZWQnICsgcm5nbmFtZV0gPSBzZWVkcmFuZG9tO1xuXG4vL1xuLy8gQVJDNFxuLy9cbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2Zcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuLy9cbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4vL1xuZnVuY3Rpb24gQVJDNChrZXkpIHtcbiAgdmFyIHQsIGtleWxlbiA9IGtleS5sZW5ndGgsXG4gICAgICBtZSA9IHRoaXMsIGkgPSAwLCBqID0gbWUuaSA9IG1lLmogPSAwLCBzID0gbWUuUyA9IFtdO1xuXG4gIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXG4gIGlmICgha2V5bGVuKSB7IGtleSA9IFtrZXlsZW4rK107IH1cblxuICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuICB3aGlsZSAoaSA8IHdpZHRoKSB7XG4gICAgc1tpXSA9IGkrKztcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyBrZXlbaSAlIGtleWxlbl0gKyAodCA9IHNbaV0pKV07XG4gICAgc1tqXSA9IHQ7XG4gIH1cblxuICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG4gIChtZS5nID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cbiAgICB2YXIgdCwgciA9IDAsXG4gICAgICAgIGkgPSBtZS5pLCBqID0gbWUuaiwgcyA9IG1lLlM7XG4gICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgIHQgPSBzW2kgPSBtYXNrICYgKGkgKyAxKV07XG4gICAgICByID0gciAqIHdpZHRoICsgc1ttYXNrICYgKChzW2ldID0gc1tqID0gbWFzayAmIChqICsgdCldKSArIChzW2pdID0gdCkpXTtcbiAgICB9XG4gICAgbWUuaSA9IGk7IG1lLmogPSBqO1xuICAgIHJldHVybiByO1xuICAgIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSwgdGhlIGZ1bmN0aW9uIGNhbGwgYmVsb3cgYXV0b21hdGljYWxseVxuICAgIC8vIGRpc2NhcmRzIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLiAgVGhpcyBpcyBjYWxsZWQgUkM0LWRyb3BbMjU2XS5cbiAgICAvLyBTZWUgaHR0cDovL2dvb2dsZS5jb20vc2VhcmNoP3E9cnNhK2ZsdWhyZXIrcmVzcG9uc2UmYnRuSVxuICB9KSh3aWR0aCk7XG59XG5cbi8vXG4vLyBjb3B5KClcbi8vIENvcGllcyBpbnRlcm5hbCBzdGF0ZSBvZiBBUkM0IHRvIG9yIGZyb20gYSBwbGFpbiBvYmplY3QuXG4vL1xuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC5qID0gZi5qO1xuICB0LlMgPSBmLlMuc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG4vL1xuLy8gZmxhdHRlbigpXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXG4vL1xuZnVuY3Rpb24gZmxhdHRlbihvYmosIGRlcHRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSwgdHlwID0gKHR5cGVvZiBvYmopLCBwcm9wO1xuICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJyk7XG59XG5cbi8vXG4vLyBtaXhrZXkoKVxuLy8gTWl4ZXMgYSBzdHJpbmcgc2VlZCBpbnRvIGEga2V5IHRoYXQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGFuZFxuLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4vL1xuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xuICB2YXIgc3RyaW5nc2VlZCA9IHNlZWQgKyAnJywgc21lYXIsIGogPSAwO1xuICB3aGlsZSAoaiA8IHN0cmluZ3NlZWQubGVuZ3RoKSB7XG4gICAga2V5W21hc2sgJiBqXSA9XG4gICAgICBtYXNrICYgKChzbWVhciBePSBrZXlbbWFzayAmIGpdICogMTkpICsgc3RyaW5nc2VlZC5jaGFyQ29kZUF0KGorKykpO1xuICB9XG4gIHJldHVybiB0b3N0cmluZyhrZXkpO1xufVxuXG4vL1xuLy8gYXV0b3NlZWQoKVxuLy8gUmV0dXJucyBhbiBvYmplY3QgZm9yIGF1dG9zZWVkaW5nLCB1c2luZyB3aW5kb3cuY3J5cHRvIGFuZCBOb2RlIGNyeXB0b1xuLy8gbW9kdWxlIGlmIGF2YWlsYWJsZS5cbi8vXG5mdW5jdGlvbiBhdXRvc2VlZCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3V0O1xuICAgIGlmIChub2RlY3J5cHRvICYmIChvdXQgPSBub2RlY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xuICAgICAgLy8gVGhlIHVzZSBvZiAnb3V0JyB0byByZW1lbWJlciByYW5kb21CeXRlcyBtYWtlcyB0aWdodCBtaW5pZmllZCBjb2RlLlxuICAgICAgb3V0ID0gb3V0KHdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgYnJvd3NlciA9IGdsb2JhbC5uYXZpZ2F0b3IsXG4gICAgICAgIHBsdWdpbnMgPSBicm93c2VyICYmIGJyb3dzZXIucGx1Z2lucztcbiAgICByZXR1cm4gWytuZXcgRGF0ZSwgZ2xvYmFsLCBwbHVnaW5zLCBnbG9iYWwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XG4gIH1cbn1cblxuLy9cbi8vIHRvc3RyaW5nKClcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xuLy9cbmZ1bmN0aW9uIHRvc3RyaW5nKGEpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCwgYSk7XG59XG5cbi8vXG4vLyBXaGVuIHNlZWRyYW5kb20uanMgaXMgbG9hZGVkLCB3ZSBpbW1lZGlhdGVseSBtaXggYSBmZXcgYml0c1xuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cbi8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXG4vLyBpbml0aWFsaXphdGlvbi5cbi8vXG5taXhrZXkobWF0aC5yYW5kb20oKSwgcG9vbCk7XG5cbi8vXG4vLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4vLyBlaXRoZXIgY29udmVudGlvbi5cbi8vXG5pZiAoKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gc2VlZHJhbmRvbTtcbiAgLy8gV2hlbiBpbiBub2RlLmpzLCB0cnkgdXNpbmcgY3J5cHRvIHBhY2thZ2UgZm9yIGF1dG9zZWVkaW5nLlxuICB0cnkge1xuICAgIG5vZGVjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgfSBjYXRjaCAoZXgpIHt9XG59IGVsc2UgaWYgKCh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VlZHJhbmRvbTsgfSk7XG59XG5cbi8vIEVuZCBhbm9ueW1vdXMgc2NvcGUsIGFuZCBwYXNzIGluaXRpYWwgdmFsdWVzLlxufSkoXG4gIFtdLCAgICAgLy8gcG9vbDogZW50cm9weSBwb29sIHN0YXJ0cyBlbXB0eVxuICBNYXRoICAgIC8vIG1hdGg6IHBhY2thZ2UgY29udGFpbmluZyByYW5kb20sIHBvdywgYW5kIHNlZWRyYW5kb21cbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2VlZHJhbmRvbS9zZWVkcmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 11:
/***/ (function(module, exports) {

	eval("/* (ignored) */\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vY3J5cHRvIChpZ25vcmVkKT9lYjlhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogKGlnbm9yZWQpICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gY3J5cHRvIChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ })

/******/ });